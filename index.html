<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Glitch Visualizer v4</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    html, body {
      margin: 0;
      padding: 0;
      width: 100%;
      height: 100%;
      overflow: hidden;
      background-color: #000000;
      font-family: 'Inter', sans-serif;
      color: white;
    }
    canvas {
      display: block;
      position: fixed;
      top: 0;
      left: 0;
      z-index: 1;
    }
    #controls {
      position: absolute;
      top: 0;
      left: 0;
      background-color: rgba(0, 0, 0, 0.7);
      padding: 0.5rem;
      border-radius: 0 0 8px 0;
      z-index: 10;
      width: 300px;
      backdrop-filter: blur(5px);
      max-height: 100vh; /* Ensure it doesn't overflow screen */
      display: flex; /* Use flex for layout */
      flex-direction: column; /* Stack children vertically */
    }
    #controls label {
      display: block;
      margin-bottom: 0.25rem;
      font-size: 0.875rem;
      font-weight: 500;
    }
    #controls input[type="range"] {
      width: 100%;
      margin-bottom: 0.75rem;
    }
    #controls input[type="number"] {
      background-color: rgba(255, 255, 255, 0.1);
      border: 1px solid rgba(255, 255, 255, 0.3);
      border-radius: 4px;
      padding: 0.25rem 0.5rem;
      width: 60px;
    }
    #controls select {
      background-color: rgba(255, 255, 255, 0.1);
      border: 1px solid rgba(255, 255, 255, 0.3);
      border-radius: 4px;
      padding: 0.25rem 0.5rem;
      width: 100%;
      margin-bottom: 0.75rem;
    }
    /* Style for disabled recording button */
    #start-recording-button:disabled {
      background-color: #4b5563; /* gray-600 */
      cursor: not-allowed;
    }
  </style>
</head>
<body>
<canvas id="visualizer-canvas"></canvas>

<!-- Updated Controls Section -->
<div id="controls" class="text-white max-h-screen flex flex-col">
  <!-- Toggle Button -->
  <button id="toggle-controls" class="flex items-center text-left flex-shrink-0">
    <!-- Arrow SVG Icon -->
    <svg id="arrow-icon" xmlns="http://www.w3.org/2000/svg" class="h-6 w-6 transition-transform duration-300 transform" fill="none" viewBox="0 0 24 24" stroke="currentColor">
      <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7" />
    </svg>
  </button>

  <!-- Collapsible Content -->
  <div id="controls-content" class="transition-all duration-300 ease-in-out max-h-0 opacity-0 overflow-y-auto">
    <h2 class="text-lg font-semibold pt-2">Controls</h2> <!-- Added text here -->
    <div class="mt-4 space-y-4"> <!-- Added spacing for controls -->

      <!-- Auto-Rotate Toggle -->
      <label for="auto-rotate-toggle" class="flex items-center justify-between cursor-pointer">
        <span class="mr-3 text-sm">Auto-Rotate</span>
        <div class="relative">
          <input type="checkbox" id="auto-rotate-toggle" class="sr-only peer" checked>
          <div class="w-14 h-8 bg-gray-600 rounded-full peer-checked:bg-purple-600 transition-colors"></div>
          <div class="absolute left-1 top-1 w-6 h-6 bg-white rounded-full transition-transform peer-checked:translate-x-full"></div>
        </div>
      </label>

      <!-- Rotation Speed Slider (now in a container) -->
      <div id="rotation-slider-container">
        <label for="rotation-slider">Rotation Speed</label>
        <input type="range" id="rotation-slider" min="0" max="0.05" step="0.001" value="0.005" class="w-full mb-2 cursor-pointer">
      </div>

      <!-- AUTO-CAMERA TOGGLE -->
      <label for="auto-camera-toggle" class="flex items-center justify-between cursor-pointer">
        <span class="mr-3 text-sm">Auto-Camera</span>
        <div class="relative">
          <input type="checkbox" id="auto-camera-toggle" class="sr-only peer">
          <div class="w-14 h-8 bg-gray-600 rounded-full peer-checked:bg-purple-600 transition-colors"></div>
          <div class="absolute left-1 top-1 w-6 h-6 bg-white rounded-full transition-transform peer-checked:translate-x-full"></div>
        </div>
      </label>

      <!-- *** SHAPE CONTROLS *** -->
      <div class="pt-4 border-t border-gray-600">
        <h3 class="text-md font-semibold mb-2">Shapes</h3>

        <!-- Shape Selector -->
        <div>
          <label for="shape-select">Shape</label>
          <select id="shape-select">
            <option value="Sphere">Sphere</option>
            <option value="Box">Box</option>
            <option value="Torus">Torus</option>
            <option value="Cone">Cone</option>
          </select>
        </div>

        <!-- MATERIAL SELECTOR -->
        <div>
          <label for="material-select">Material</label>
          <select id="material-select">
            <option value="Hue">Hue (Normal)</option>
            <option value="Monochrome">Monochrome</option>
            <option value="Lit">Lit (White)</option>
          </select>
        </div>

        <!-- SMOOTH SURFACE TOGGLE -->
        <label for="smooth-surface-toggle" class="flex items-center cursor-pointer">
          <span class="mr-3 text-sm">Smooth Surface</span>
          <div class="relative">
            <input type="checkbox" id="smooth-surface-toggle" class="sr-only peer">
            <div class="w-14 h-8 bg-gray-600 rounded-full peer-checked:bg-purple-600 transition-colors"></div>
            <div class="absolute left-1 top-1 w-6 h-6 bg-white rounded-full transition-transform peer-checked:translate-x-full"></div>
          </div>
        </label>

        <!-- *** NEW: SHAPE COUNT SLIDER *** -->
        <div class="mt-2">
          <label for="shape-count-slider">Shape Count</label>
          <div class="flex justify-between items-center mb-2">
            <input type="range" id="shape-count-slider" min="1" max="50" step="1" value="1" class="w-full cursor-pointer mr-3">
            <span id="shape-count-value" class="text-sm text-gray-300 w-6 text-right">1</span>
          </div>
        </div>
        <!-- *** END NEW *** -->

        <!-- Shape-Specific Controls Container -->
        <div id="shape-controls-container">
          <!-- Sphere Controls -->
          <div id="sphere-controls">
            <label for="detail-slider">Sphere Detail</label>
            <div class="flex justify-between items-center mb-2">
              <input type="range" id="detail-slider" min="0" max="50" step="1" value="3" class="w-full cursor-pointer mr-3">
              <span id="detail-value" class="text-sm text-gray-300 w-6 text-right">3</span>
            </div>
          </div>
          <!-- Box Controls -->
          <div id="box-controls" class="hidden">
            <label for="box-segments-slider">Box Segments</label>
            <div class="flex justify-between items-center mb-2">
              <input type="range" id="box-segments-slider" min="1" max="50" step="1" value="1" class="w-full cursor-pointer mr-3">
              <span id="box-segments-value" class="text-sm text-gray-300 w-6 text-right">1</span>
            </div>
          </div>
          <!-- Torus Controls -->
          <div id="torus-controls" class="hidden">
            <label for="torus-radial-slider">Torus Radial Segments</label>
            <div class="flex justify-between items-center mb-2">
              <input type="range" id="torus-radial-slider" min="3" max="100" step="1" value="16" class="w-full cursor-pointer mr-3">
              <span id="torus-radial-value" class="text-sm text-gray-300 w-6 text-right">16</span>
            </div>
            <label for="torus-tubular-slider">Torus Tubular Segments</label>
            <div class="flex justify-between items-center mb-2">
              <input type="range" id="torus-tubular-slider" min="3" max="100" step="1" value="100" class="w-full cursor-pointer mr-3">
              <span id="torus-tubular-value" class="text-sm text-gray-300 w-6 text-right">100</span>
            </div>
          </div>
          <!-- Cone Controls -->
          <div id="cone-controls" class="hidden">
            <label for="cone-segments-slider">Cone Radial Segments</label>
            <div class="flex justify-between items-center mb-2">
              <input type="range" id="cone-segments-slider" min="3" max="100" step="1" value="32" class="w-full cursor-pointer mr-3">
              <span id="cone-segments-value" class="text-sm text-gray-300 w-6 text-right">32</span>
            </div>
          </div>
        </div>
        <!-- End Shape-Specific Controls -->
      </div>
      <!-- --- END SHAPE CONTROLS --- -->


      <!-- --- EFFECTS CONTROLS --- -->
      <div class="pt-4 border-t border-gray-600">
        <h3 class="text-md font-semibold mb-2">Effects</h3>
        <!-- BPM Slider -->
        <div>
          <label for="bpm-slider">BPM</label>
          <div class="flex justify-between items-center mb-2">
            <input type="range" id="bpm-slider" min="60" max="180" step="1" value="120" class="w-full cursor-pointer mr-3">
            <span id="bpm-value" class="text-sm text-gray-300 w-6 text-right">120</span>
          </div>
        </div>

        <!-- BPM PULSE Toggle Switch -->
        <label for="pulse-effects-toggle" class="flex items-center justify-between cursor-pointer">
          <span class="mr-3 text-sm">BPM Pulse Effects</span>
          <div class="relative">
            <input type="checkbox" id="pulse-effects-toggle" class="sr-only peer" checked>
            <div class="w-14 h-8 bg-gray-600 rounded-full peer-checked:bg-purple-600 transition-colors"></div>
            <div class="absolute left-1 top-1 w-6 h-6 bg-white rounded-full transition-transform peer-checked:translate-x-full"></div>
          </div>
        </label>

        <!-- *** NEW: RANDOM GLITCH TOGGLE *** -->
        <label for="random-glitch-toggle" class="flex items-center justify-between cursor-pointer mt-2">
          <span class="mr-3 text-sm">Random Glitch</span>
          <div class="relative">
            <input type="checkbox" id="random-glitch-toggle" class="sr-only peer">
            <div class="w-14 h-8 bg-gray-600 rounded-full peer-checked:bg-red-600 transition-colors"></div>
            <div class="absolute left-1 top-1 w-6 h-6 bg-white rounded-full transition-transform peer-checked:translate-x-full"></div>
          </div>
        </label>

        <!-- Film Grain Sliders -->
        <div class="mt-4">
          <label for="film-noise-slider">Film Noise</label>
          <input type="range" id="film-noise-slider" min="0" max="2" step="0.05" value="0.2" class="w-full mb-2 cursor-pointer">
        </div>
        <div>
          <label for="film-scanline-slider">Film Scanlines</label>
          <input type="range" id="film-scanline-slider" min="0" max="1" step="0.01" value="0.1" class="w-full mb-2 cursor-pointer">
        </div>

        <!-- *** NEW: AFTERIMAGE CONTROLS *** -->
        <label for="afterimage-toggle" class="flex items-center justify-between cursor-pointer mt-4">
          <span class="mr-3 text-sm">Afterimage (Trails)</span>
          <div class="relative">
            <input type="checkbox" id="afterimage-toggle" class="sr-only peer">
            <div class="w-14 h-8 bg-gray-600 rounded-full peer-checked:bg-blue-600 transition-colors"></div>
            <div class="absolute left-1 top-1 w-6 h-6 bg-white rounded-full transition-transform peer-checked:translate-x-full"></div>
          </div>
        </label>
        <div class="mt-2">
          <label for="afterimage-damp-slider">Afterimage Damp (Fade)</label>
          <input type="range" id="afterimage-damp-slider" min="0.5" max="0.99" step="0.01" value="0.9" class="w-full mb-2 cursor-pointer">
        </div>

        <!-- *** NEW: DOT SCREEN CONTROLS *** -->
        <label for="dot-screen-toggle" class="flex items-center justify-between cursor-pointer mt-2">
          <span class="mr-3 text-sm">Dot Screen</span>
          <div class="relative">
            <input type="checkbox" id="dot-screen-toggle" class="sr-only peer">
            <div class="w-14 h-8 bg-gray-600 rounded-full peer-checked:bg-blue-600 transition-colors"></div>
            <div class="absolute left-1 top-1 w-6 h-6 bg-white rounded-full transition-transform peer-checked:translate-x-full"></div>
          </div>
        </label>
        <div class="mt-2">
          <label for="dot-screen-scale-slider">Dot Screen Scale</label>
          <input type="range" id="dot-screen-scale-slider" min="0.1" max="5" step="0.1" value="1" class="w-full mb-2 cursor-pointer">
        </div>

      </div>
      <!-- --- END EFFECTS CONTROLS --- -->


      <!-- Recording Section -->
      <div class="pt-4 border-t border-gray-600">
        <h3 class="text-md font-semibold mb-2">Recording & Saving</h3>
        <div class="flex items-center justify-between mb-2">
          <label for="recording-duration" class="text-sm">Duration (sec):</label>
          <input type="number" id="recording-duration" min="1" max="60" value="10" class="text-white text-sm">
        </div>
        <button id="start-recording-button" class="w-full bg-purple-600 hover:bg-purple-700 text-white font-bold py-2 px-4 rounded transition-colors">
          Start Recording
        </button>

        <!-- IMAGE ORIENTATION TOGGLE -->
        <label for="image-orientation-toggle" class="flex items-center justify-between cursor-pointer mt-4">
          <span class="mr-3 text-sm">Portrait Image (9:16)</span>
          <div class="relative">
            <input type="checkbox" id="image-orientation-toggle" class="sr-only peer">
            <div class="w-14 h-8 bg-gray-600 rounded-full peer-checked:bg-blue-600 transition-colors"></div>
            <div class="absolute left-1 top-1 w-6 h-6 bg-white rounded-full transition-transform peer-checked:translate-x-full"></div>
          </div>
        </label>

        <!-- TRANSPARENT BG TOGGLE -->
        <label for="transparent-bg-toggle" class="flex items-center justify-between cursor-pointer mt-2">
          <span class="mr-3 text-sm">Transparent Background</span>
          <div class="relative">
            <input type="checkbox" id="transparent-bg-toggle" class="sr-only peer">
            <div class="w-14 h-8 bg-gray-600 rounded-full peer-checked:bg-blue-600 transition-colors"></div>
            <div class="absolute left-1 top-1 w-6 h-6 bg-white rounded-full transition-transform peer-checked:translate-x-full"></div>
          </div>
        </label>

        <button id="save-image-button" class="w-full bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded transition-colors mt-2">
          Save Image
        </button>
        <span id="recording-status" class="text-sm text-yellow-300 mt-2 hidden">Recording...</span>
        <p class="text-xs text-gray-400 mt-2">Saves a .webm file. Use an online converter if you need .mp4.</p>
      </div>

    </div>
  </div>
</div>
<!-- End of Updated Controls Section -->


<script type="importmap">
  {
    "imports": {
      "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
      "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
    }
  }
</script>

<!--
  Main application logic.
-->
<script type="module">
  import * as THREE from 'three';
  import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
  import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
  import { GlitchPass } from 'three/addons/postprocessing/GlitchPass.js';
  import { ShaderPass } from 'three/addons/postprocessing/ShaderPass.js';
  import { HueSaturationShader } from 'three/addons/shaders/HueSaturationShader.js';
  import { SMAAPass } from 'three/addons/postprocessing/SMAAPass.js';
  // --- NEW IMPORTS ---
  import { FilmPass } from 'three/addons/postprocessing/FilmPass.js';
  import { RGBShiftShader } from 'three/addons/shaders/RGBShiftShader.js';
  import { AfterimagePass } from 'three/addons/postprocessing/AfterimagePass.js';
  import { DotScreenPass } from 'three/addons/postprocessing/DotScreenPass.js';
  // --- END NEW IMPORTS ---

  /**
   * Main class for the Glitch Visualizer application.
   */
  class GlitchVisualizer {
    /** @type {THREE.Scene} */
    scene;
    /** @type {THREE.PerspectiveCamera} */
    camera;
    /** @type {THREE.WebGLRenderer} */
    renderer;
    /** @type {EffectComposer} */
    composer;
    /** @type {GlitchPass} */
    glitchPass;
    /** @type {ShaderPass} */
    huePass;
    /** @type {SMAAPass} */
    smaaPass;

    // --- UPDATED: MESH MANAGEMENT ---
    /** @type {THREE.Mesh[]} */
    meshes = [];
    /** @type {THREE.Group} */
    meshGroup;
    // --- END MESH MANAGEMENT ---

    /** @type {THREE.PointLight} */
    pointLight;
    /** @type {THREE.AmbientLight} */
    ambientLight;

    // --- NEW EFFECT PASSES ---
    /** @type {FilmPass} */
    filmPass;
    /** @type {ShaderPass} */
    rgbShiftPass;
    /** @type {AfterimagePass} */
    afterimagePass;
    /** @type {DotScreenPass} */
    dotScreenPass;
    // --- END NEW EFFECT PASSES ---

    // --- Rotation Controls ---
    /** @type {HTMLInputElement} */
    autoRotateToggle;
    /** @type {HTMLInputElement} */
    rotationSlider;
    /** @type {HTMLDivElement} */
    rotationSliderContainer;
    /** @type {boolean} */
    isAutoRotate = true;

    // --- Camera Controls ---
    /** @type {HTMLInputElement} */
    autoCameraToggle;
    /** @type {boolean} */
    isAutoCamera = false;

    // --- Shape Controls ---
    /** @type {HTMLSelectElement} */
    shapeSelect;
    /** @type {string} */
    currentShape = 'Sphere';
    /** @type {HTMLDivElement} */
    sphereControls;
    /** @type {HTMLInputElement} */
    detailSlider;
    /** @type {HTMLSpanElement} */
    detailValueSpan;
    /** @type {HTMLDivElement} */
    boxControls;
    /** @type {HTMLInputElement} */
    boxSegmentsSlider;
    /** @type {HTMLSpanElement} */
    boxSegmentsValue;
    /** @type {HTMLDivElement} */
    torusControls;
    /** @type {HTMLInputElement} */
    torusRadialSlider;
    /** @type {HTMLSpanElement} */
    torusRadialValue;
    /** @type {HTMLInputElement} */
    torusTubularSlider;
    /** @type {HTMLSpanElement} */
    torusTubularValue;
    /** @type {HTMLDivElement} */
    coneControls;
    /** @type {HTMLInputElement} */
    coneSegmentsSlider;
    /** @type {HTMLSpanElement} */
    coneSegmentsValue;

    // --- NEW: Shape Count Controls ---
    /** @type {HTMLInputElement} */
    shapeCountSlider;
    /** @type {HTMLSpanElement} */
    shapeCountValue;
    /** @type {number} */
    shapeCount = 1;
    // --- END NEW ---

    // --- Other Controls ---
    /** @type {HTMLInputElement} */
    bpmSlider;
    /** @type {HTMLSpanElement} */
    bpmValueSpan;
    /** @type {HTMLInputElement} */
    pulseEffectsToggle;
    /** @type {HTMLSelectElement} */
    materialSelect;
    /** @type {HTMLInputElement} */
    smoothSurfaceToggle;

    // --- NEW EFFECT CONTROLS ---
    /** @type {HTMLInputElement} */
    filmNoiseSlider;
    /** @type {HTMLInputElement} */
    filmScanlineSlider;
    /** @type {HTMLInputElement} */
    randomGlitchToggle;
    /** @type {HTMLInputElement} */
    afterimageToggle;
    /** @type {HTMLInputElement} */
    afterimageSlider;
    /** @type {HTMLInputElement} */
    dotScreenToggle;
    /** @type {HTMLInputElement} */
    dotScreenSlider;
    // --- END NEW EFFECT CONTROLS ---


    // --- New UI elements for collapsible controls ---
    /** @type {HTMLButtonElement} */
    toggleButton;
    /** @type {HTMLDivElement} */
    controlsContent;
    /** @type {HTMLElement} */
    arrowIcon;
    // --- End of new UI elements ---

    // --- New Recording Properties ---
    /** @type {HTMLInputElement} */
    recordingDurationInput;
    /** @type {HTMLButtonElement} */
    startRecordingButton;
    /** @type {HTMLButtonElement} */
    saveImageButton;
    /** @type {HTMLInputElement} */
    imageOrientationToggle;
    /** @type {HTMLInputElement} */
    transparentBgToggle;
    /** @type {HTMLSpanElement} */
    recordingStatus;
    /** @type {MediaRecorder | null} */
    mediaRecorder = null;
    /** @type {Blob[]} */
    recordedChunks = [];
    /** @type {boolean} */
    isRecording = false;
    /** @type {boolean} */
    isPortraitMode = false;
    /** @type {boolean} */
    isTransparentBackground = false;
    /** @type {string} */
    materialMode = 'Hue';
    /** @type {boolean} */
    isSmoothSurface = false;
    /** @type {number | undefined} */
    originalRecordingAlpha;
    // --- End Recording Properties ---

    /** @type {number} */
    rotationSpeed = 0.005;
    /** @type {number} */
    hueValue = 0;

    // --- Shape Detail Properties ---
    /** @type {number} */
    sphereDetail = 3;
    /** @type {number} */
    boxSegments = 1;
    /** @type {number} */
    torusRadialSeg = 16;
    /** @type {number} */
    torusTubularSeg = 100;
    /** @type {number} */
    coneRadialSeg = 32;


    // --- BPM and Glitch Timing Properties ---
    /** @type {number} */
    bpm = 120;
    /** @type {number} */
    lastBeatTime = 0;
    /** @type {number} */
    glitchDuration = 100;
    /** @type {boolean} */
    isPulseEffectsEnabled = true;

    // --- NEW EFFECT PROPERTIES ---
    /** @type {number} */
    baseFilmNoise = 0.2;
    /** @type {number} */
    baseFilmScanlines = 0.1;
    /** @type {boolean} */
    isRandomGlitchEnabled = false;
    /** @type {boolean} */
    isAfterimageEnabled = false;
    /** @type {boolean} */
    isDotScreenEnabled = false;
    // --- END NEW EFFECT PROPERTIES ---

    /** @type {boolean} */
    isConstructed = false; // Flag to check if constructor finished

    constructor() {
      const canvas = document.getElementById('visualizer-canvas');
      if (!canvas) {
        console.error("Canvas element not found!");
        return;
      }

      // --- Three.js Setup ---
      this.scene = new THREE.Scene();
      this.camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);

      this.renderer = new THREE.WebGLRenderer({
        canvas: canvas,
        antialias: true,
        preserveDrawingBuffer: true,
        alpha: true
      });

      this.renderer.setPixelRatio(window.devicePixelRatio);
      this.renderer.setSize(window.innerWidth, window.innerHeight);


      // --- Post-processing (Effect) Setup ---
      this.composer = new EffectComposer(this.renderer);
      const renderPass = new RenderPass(this.scene, this.camera);
      this.composer.addPass(renderPass);

      // Glitch Pass
      this.glitchPass = new GlitchPass();
      this.glitchPass.enabled = false; // Start disabled, will be pulsed
      this.composer.addPass(this.glitchPass);

      // --- NEW: Film Pass ---
      // Get base values from sliders *before* initializing
      this.filmNoiseSlider = document.getElementById('film-noise-slider');
      this.filmScanlineSlider = document.getElementById('film-scanline-slider');
      this.baseFilmNoise = this.filmNoiseSlider ? parseFloat(this.filmNoiseSlider.value) : 0.2;
      this.baseFilmScanlines = this.filmScanlineSlider ? parseFloat(this.filmScanlineSlider.value) : 0.1;

      this.filmPass = new FilmPass(
        this.baseFilmNoise,
        this.baseFilmScanlines,
        648,  // scanlineCount
        false // grayscale
      );
      this.composer.addPass(this.filmPass); // Always enabled, but values will pulse
      // --- END NEW ---

      // Hue Pass
      this.huePass = new ShaderPass(HueSaturationShader);
      this.composer.addPass(this.huePass);
      // Note: huePass.enabled is set after controls are initialized

      // --- NEW: RGB Shift Pass ---
      this.rgbShiftPass = new ShaderPass(RGBShiftShader);
      this.rgbShiftPass.uniforms['amount'].value = 0.0; // Start at 0, will pulse
      this.composer.addPass(this.rgbShiftPass); // Always enabled, but amount will pulse
      // --- END NEW ---

      // --- NEW: Dot Screen Pass ---
      this.dotScreenPass = new DotScreenPass();
      this.dotScreenPass.enabled = false; // Start disabled
      this.composer.addPass(this.dotScreenPass);
      // --- END NEW ---

      // --- NEW: Afterimage Pass ---
      this.afterimagePass = new AfterimagePass();
      this.afterimagePass.enabled = false; // Start disabled
      this.composer.addPass(this.afterimagePass);
      // --- END NEW ---


      // --- SMAA PASS (MUST BE LAST) ---
      const pixelRatio = this.renderer.getPixelRatio();
      this.smaaPass = new SMAAPass(
        window.innerWidth * pixelRatio,
        window.innerHeight * pixelRatio
      );
      this.composer.addPass(this.smaaPass);
      // --- END OF COMPOSER CHAIN ---

      // --- UI Elements ---
      this.autoRotateToggle = document.getElementById('auto-rotate-toggle');
      this.rotationSliderContainer = document.getElementById('rotation-slider-container');
      this.rotationSlider = document.getElementById('rotation-slider');

      this.autoCameraToggle = document.getElementById('auto-camera-toggle');

      this.shapeSelect = document.getElementById('shape-select');

      this.sphereControls = document.getElementById('sphere-controls');
      this.detailSlider = document.getElementById('detail-slider');
      this.detailValueSpan = document.getElementById('detail-value');

      this.boxControls = document.getElementById('box-controls');
      this.boxSegmentsSlider = document.getElementById('box-segments-slider');
      this.boxSegmentsValue = document.getElementById('box-segments-value');

      this.torusControls = document.getElementById('torus-controls');
      this.torusRadialSlider = document.getElementById('torus-radial-slider');
      this.torusRadialValue = document.getElementById('torus-radial-value');
      this.torusTubularSlider = document.getElementById('torus-tubular-slider');
      this.torusTubularValue = document.getElementById('torus-tubular-value');

      this.coneControls = document.getElementById('cone-controls');
      this.coneSegmentsSlider = document.getElementById('cone-segments-slider');
      this.coneSegmentsValue = document.getElementById('cone-segments-value');

      // --- NEW: Get Shape Count UI ---
      this.shapeCountSlider = document.getElementById('shape-count-slider');
      this.shapeCountValue = document.getElementById('shape-count-value');
      // --- END NEW ---

      this.bpmSlider = document.getElementById('bpm-slider');
      this.bpmValueSpan = document.getElementById('bpm-value');
      this.pulseEffectsToggle = document.getElementById('pulse-effects-toggle');
      this.materialSelect = document.getElementById('material-select');
      this.smoothSurfaceToggle = document.getElementById('smooth-surface-toggle');

      // filmNoiseSlider and filmScanlineSlider are already retrieved above

      // --- NEW: Get new effect UI elements ---
      this.randomGlitchToggle = document.getElementById('random-glitch-toggle');
      this.afterimageToggle = document.getElementById('afterimage-toggle');
      this.afterimageSlider = document.getElementById('afterimage-damp-slider');
      this.dotScreenToggle = document.getElementById('dot-screen-toggle');
      this.dotScreenSlider = document.getElementById('dot-screen-scale-slider');
      // --- END NEW ---

      this.toggleButton = document.getElementById('toggle-controls');
      this.controlsContent = document.getElementById('controls-content');
      this.arrowIcon = document.getElementById('arrow-icon');

      // --- Get Recording UI Elements ---
      this.recordingDurationInput = document.getElementById('recording-duration');
      this.startRecordingButton = document.getElementById('start-recording-button');
      this.saveImageButton = document.getElementById('save-image-button');
      this.imageOrientationToggle = document.getElementById('image-orientation-toggle');
      this.transparentBgToggle = document.getElementById('transparent-bg-toggle');
      this.recordingStatus = document.getElementById('recording-status');

      // --- UPDATED: Create mesh group ---
      this.meshGroup = new THREE.Group();
      this.scene.add(this.meshGroup);
      // --- END UPDATED ---

      // Check if all UI elements were found
      if (
        !this.autoRotateToggle || !this.rotationSliderContainer || !this.rotationSlider ||
        !this.autoCameraToggle ||
        !this.shapeSelect ||
        !this.sphereControls || !this.detailSlider || !this.detailValueSpan ||
        !this.boxControls || !this.boxSegmentsSlider || !this.boxSegmentsValue ||
        !this.torusControls || !this.torusRadialSlider || !this.torusRadialValue || !this.torusTubularSlider || !this.torusTubularValue ||
        !this.coneControls || !this.coneSegmentsSlider || !this.coneSegmentsValue ||
        !this.shapeCountSlider || !this.shapeCountValue || // <-- NEW CHECK
        !this.bpmSlider || !this.bpmValueSpan ||
        !this.pulseEffectsToggle || !this.materialSelect ||
        !this.filmNoiseSlider || !this.filmScanlineSlider ||
        !this.smoothSurfaceToggle ||
        // --- NEW: Add new controls to check ---
        !this.randomGlitchToggle || !this.afterimageToggle || !this.afterimageSlider ||
        !this.dotScreenToggle || !this.dotScreenSlider ||
        // --- END NEW ---
        !this.toggleButton || !this.controlsContent || !this.arrowIcon ||
        !this.recordingDurationInput || !this.startRecordingButton || !this.recordingStatus ||
        !this.saveImageButton || !this.imageOrientationToggle || !this.transparentBgToggle
      ) {
        console.error("Initialization Error: One or more UI elements not found!");
        return; // Return early, isConstructed will be false
      }

      // Set initial values from controls
      this.isAutoRotate = this.autoRotateToggle.checked;
      this.rotationSliderContainer.style.display = this.isAutoRotate ? 'none' : 'block';
      this.rotationSpeed = parseFloat(this.rotationSlider.value);

      this.isAutoCamera = this.autoCameraToggle.checked;

      this.currentShape = this.shapeSelect.value;
      this.sphereDetail = parseInt(this.detailSlider.value);
      this.boxSegments = parseInt(this.boxSegmentsSlider.value);
      this.torusRadialSeg = parseInt(this.torusRadialSlider.value);
      this.torusTubularSeg = parseInt(this.torusTubularSlider.value);
      this.coneRadialSeg = parseInt(this.coneSegmentsSlider.value);

      // --- NEW: Set initial shape count ---
      this.shapeCount = parseInt(this.shapeCountSlider.value);
      this.shapeCountValue.textContent = this.shapeCount;
      // --- END NEW ---

      this.bpm = parseFloat(this.bpmSlider.value);
      this.bpmValueSpan.textContent = this.bpm;
      this.isPulseEffectsEnabled = this.pulseEffectsToggle.checked;

      this.isPortraitMode = this.imageOrientationToggle.checked;
      this.isTransparentBackground = this.transparentBgToggle.checked;
      this.materialMode = this.materialSelect.value;
      this.isSmoothSurface = this.smoothSurfaceToggle.checked;

      this.huePass.enabled = (this.materialMode === 'Hue');

      // --- NEW: Set initial values for new effects ---
      this.isRandomGlitchEnabled = this.randomGlitchToggle.checked;

      this.isAfterimageEnabled = this.afterimageToggle.checked;
      this.afterimagePass.enabled = this.isAfterimageEnabled;
      this.afterimagePass.uniforms['damp'].value = parseFloat(this.afterimageSlider.value);

      this.isDotScreenEnabled = this.dotScreenToggle.checked;
      this.dotScreenPass.enabled = this.isDotScreenEnabled;
      this.dotScreenPass.uniforms['scale'].value = parseFloat(this.dotScreenSlider.value);
      // --- END NEW ---

      this.updateShapeControls(); // Set initial control visibility

      this.isConstructed = true; // All good, set flag
    }

    /**
     * Initializes the scene and event listeners.
     */
    init() {
      if (!this.isConstructed) {
        console.error("Initialization failed: Constructor did not complete.");
        return;
      }

      this.initScene();
      this.setupEventListeners();
      this.onWindowResize(); // Set initial size
      this.updateMeshInstances(); // Create initial mesh(es)
      this.animate(); // Start animation loop immediately
    }

    /**
     * Hides/shows the correct detail sliders based on the selected shape.
     */
    updateShapeControls() {
      this.sphereControls.classList.add('hidden');
      this.boxControls.classList.add('hidden');
      this.torusControls.classList.add('hidden');
      this.coneControls.classList.add('hidden');

      switch (this.currentShape) {
        case 'Box':
          this.boxControls.classList.remove('hidden');
          break;
        case 'Torus':
          this.torusControls.classList.remove('hidden');
          break;
        case 'Cone':
          this.coneControls.classList.remove('hidden');
          break;
        case 'Sphere':
        default:
          this.sphereControls.classList.remove('hidden');
          break;
      }
    }

    /**
     * Clears all existing meshes and creates new ones based on current settings.
     */
    updateMeshInstances() {
      // 1. Clear existing meshes
      this.meshes.forEach(mesh => {
        mesh.geometry.dispose();
        // Material might be shared, but if it's an array, dispose all
        if (Array.isArray(mesh.material)) {
          mesh.material.forEach(m => m.dispose());
        } else {
          mesh.material.dispose();
        }
      });
      this.meshGroup.clear(); // Remove all children from the group
      this.meshes = []; // Reset the array

      // 2. Get the base geometry and material
      const { geometry, material } = this.createBaseGeometryAndMaterial();

      // 3. Create and add new instances
      for (let i = 0; i < this.shapeCount; i++) {
        const mesh = new THREE.Mesh(geometry, material);

        // 4. Set position and rotation
        if (this.shapeCount === 1) {
          mesh.position.set(0, 0, 0);
          mesh.rotation.set(0, 0, 0);
        } else {
          // Spread shapes out randomly
          mesh.position.set(
            (Math.random() - 0.5) * 7,
            (Math.random() - 0.5) * 7,
            (Math.random() - 0.5) * 7
          );
          mesh.rotation.set(
            Math.random() * 2 * Math.PI,
            Math.random() * 2 * Math.PI,
            Math.random() * 2 * Math.PI
          );
        }

        // 5. Add to group and array
        this.meshGroup.add(mesh);
        this.meshes.push(mesh);
      }
    }


    /**
     * Creates and returns a single geometry and material based on current controls.
     * Does NOT add anything to the scene.
     * @returns {{geometry: THREE.BufferGeometry, material: THREE.Material}}
     */
    createBaseGeometryAndMaterial() {
      let geometry;

      // --- GEOMETRY LOGIC ---
      switch (this.currentShape) {
        case 'Box':
          const seg = this.boxSegments;
          geometry = new THREE.BoxGeometry(1.5, 1.5, 1.5, seg, seg, seg);
          break;
        case 'Torus':
          geometry = new THREE.TorusGeometry(1, 0.4, this.torusRadialSeg, this.torusTubularSeg);
          break;
        case 'Cone':
          geometry = new THREE.ConeGeometry(1, 2, this.coneRadialSeg, 1, false, 0, Math.PI * 2);
          break;
        case 'Sphere':
        default:
          geometry = new THREE.IcosahedronGeometry(1, this.sphereDetail);
          break;
      }

      // --- MATERIAL LOGIC ---
      let material;
      const wireframe = !this.isSmoothSurface;

      switch (this.materialMode) {
        case 'Monochrome':
          material = new THREE.MeshBasicMaterial({
            color: 0xffffff,
            wireframe: wireframe
          });
          break;
        case 'Lit':
          material = new THREE.MeshPhongMaterial({
            color: 0xffffff,
            wireframe: wireframe,
            flatShading: this.isSmoothSurface
          });
          break;
        case 'Hue':
        default:
          material = new THREE.MeshNormalMaterial({
            wireframe: wireframe,
            flatShading: this.isSmoothSurface
          });
          break;
      }

      return { geometry, material };
    }

    /**
     * Creates the 3D objects for the scene.
     */
    initScene() {
      // --- ADDED LIGHTS ---
      this.ambientLight = new THREE.AmbientLight(0x404040); // soft white light
      this.scene.add(this.ambientLight);

      this.pointLight = new THREE.PointLight(0xffffff, 1, 100);
      this.pointLight.position.set(5, 5, 5); // Position the light
      this.scene.add(this.pointLight);
      // --- END LIGHTS ---

      // Note: Mesh creation is now handled by updateMeshInstances() in init()

      this.camera.position.z = 5;
    }

    /**
     * Sets up event listeners for UI interaction and window resizing.
     */
    setupEventListeners() {
      window.addEventListener('resize', () => this.onWindowResize());

      // --- Rotation Listeners ---
      this.autoRotateToggle.addEventListener('change', (e) => {
        this.isAutoRotate = e.target.checked;
        this.rotationSliderContainer.style.display = this.isAutoRotate ? 'none' : 'block';
      });
      this.rotationSlider.addEventListener('input', (e) => {
        this.rotationSpeed = parseFloat(e.target.value);
      });

      // --- Auto-Camera Listener ---
      this.autoCameraToggle.addEventListener('change', (e) => {
        this.isAutoCamera = e.target.checked;
        if (!this.isAutoCamera) {
          // Reset camera to default if auto-camera is turned off
          this.camera.position.set(0, 0, 5);
          this.camera.lookAt(0, 0, 0); // Look at center
        }
      });

      // --- Shape Listeners ---
      this.shapeSelect.addEventListener('change', (e) => {
        this.currentShape = e.target.value;
        this.updateShapeControls();
        this.updateMeshInstances(); // <-- UPDATED
      });

      // --- NEW: Shape Count Listener ---
      this.shapeCountSlider.addEventListener('input', (e) => {
        this.shapeCount = parseInt(e.target.value);
        this.shapeCountValue.textContent = this.shapeCount;
        this.updateMeshInstances(); // Rebuild all meshes
      });
      // --- END NEW ---

      // Sphere
      this.detailSlider.addEventListener('input', (e) => {
        this.sphereDetail = parseInt(e.target.value);
        if (this.detailValueSpan) {
          this.detailValueSpan.textContent = this.sphereDetail;
        }
        this.updateMeshInstances(); // <-- UPDATED
      });

      // Box
      this.boxSegmentsSlider.addEventListener('input', (e) => {
        this.boxSegments = parseInt(e.target.value);
        if (this.boxSegmentsValue) {
          this.boxSegmentsValue.textContent = this.boxSegments;
        }
        this.updateMeshInstances(); // <-- UPDATED
      });

      // Torus
      this.torusRadialSlider.addEventListener('input', (e) => {
        this.torusRadialSeg = parseInt(e.target.value);
        if (this.torusRadialValue) {
          this.torusRadialValue.textContent = this.torusRadialSeg;
        }
        this.updateMeshInstances(); // <-- UPDATED
      });
      this.torusTubularSlider.addEventListener('input', (e) => {
        this.torusTubularSeg = parseInt(e.target.value);
        if (this.torusTubularValue) {
          this.torusTubularValue.textContent = this.torusTubularSeg;
        }
        this.updateMeshInstances(); // <-- UPDATED
      });

      // Cone
      this.coneSegmentsSlider.addEventListener('input', (e) => {
        this.coneRadialSeg = parseInt(e.target.value);
        if (this.coneSegmentsValue) {
          this.coneSegmentsValue.textContent = this.coneRadialSeg;
        }
        this.updateMeshInstances(); // <-- UPDATED
      });

      // --- Other Control Listeners ---
      this.bpmSlider.addEventListener('input', (e) => {
        this.bpm = parseFloat(e.target.value);
        if (this.bpmValueSpan) {
          this.bpmValueSpan.textContent = this.bpm;
        }
      });

      // --- UPDATED: Pulse Effects Listener ---
      this.pulseEffectsToggle.addEventListener('change', (e) => {
        this.isPulseEffectsEnabled = e.target.checked;
        if (!this.isPulseEffectsEnabled) {
          // Reset all pulse effects if disabled
          this.glitchPass.enabled = false;
          this.rgbShiftPass.uniforms['amount'].value = 0.0;
          // --- FIX: Add safety check ---
          if (this.filmPass && this.filmPass.uniforms && this.filmPass.uniforms.nIntensity && this.filmPass.uniforms.sIntensity) {
            this.filmPass.uniforms['nIntensity'].value = this.baseFilmNoise;
            this.filmPass.uniforms['sIntensity'].value = this.baseFilmScanlines;
          }
        }
      });
      // --- END UPDATE ---

      // --- NEW: Random Glitch Listener ---
      this.randomGlitchToggle.addEventListener('change', (e) => {
        this.isRandomGlitchEnabled = e.target.checked;
      });
      // --- END NEW ---

      // --- NEW: Film Slider Listeners ---
      this.filmNoiseSlider.addEventListener('input', (e) => {
        this.baseFilmNoise = parseFloat(e.target.value);
        if (!this.isPulseEffectsEnabled || !this.glitchPass.enabled) {
          // --- FIX: Add safety check ---
          if (this.filmPass && this.filmPass.uniforms && this.filmPass.uniforms.nIntensity) {
            this.filmPass.uniforms['nIntensity'].value = this.baseFilmNoise;
          }
        }
      });
      this.filmScanlineSlider.addEventListener('input', (e) => {
        this.baseFilmScanlines = parseFloat(e.target.value);
        if (!this.isPulseEffectsEnabled || !this.glitchPass.enabled) {
          // --- FIX: Add safety check ---
          if (this.filmPass && this.filmPass.uniforms && this.filmPass.uniforms.sIntensity) {
            this.filmPass.uniforms['sIntensity'].value = this.baseFilmScanlines;
          }
        }
      });
      // --- END NEW ---

      // --- NEW: Afterimage Listeners ---
      this.afterimageToggle.addEventListener('change', (e) => {
        this.isAfterimageEnabled = e.target.checked;
        this.afterimagePass.enabled = this.isAfterimageEnabled;
      });
      this.afterimageSlider.addEventListener('input', (e) => {
        if (this.afterimagePass) {
          this.afterimagePass.uniforms['damp'].value = parseFloat(e.target.value);
        }
      });
      // --- END NEW ---

      // --- NEW: Dot Screen Listeners ---
      this.dotScreenToggle.addEventListener('change', (e) => {
        this.isDotScreenEnabled = e.target.checked;
        this.dotScreenPass.enabled = this.isDotScreenEnabled;
      });
      this.dotScreenSlider.addEventListener('input', (e) => {
        if (this.dotScreenPass) {
          this.dotScreenPass.uniforms['scale'].value = parseFloat(e.target.value);
        }
      });
      // --- END NEW ---


      this.toggleButton.addEventListener('click', () => {
        if (this.controlsContent && this.arrowIcon) {
          this.controlsContent.classList.toggle('max-h-0');
          this.controlsContent.classList.toggle('opacity-0');
          this.controlsContent.classList.toggle('flex-1'); // Allow flexible growth
          this.controlsContent.classList.toggle('opacity-100');
          this.arrowIcon.classList.toggle('rotate-180');
        }
      });

      // --- Add recording button listener ---
      this.startRecordingButton.addEventListener('click', () => {
        if (!this.isRecording) {
          this.startRecording();
        }
      });

      // --- ADDED SAVE IMAGE LISTENER ---
      this.saveImageButton.addEventListener('click', () => {
        this.saveImage();
      });

      // --- ADDED ORIENTATION TOGGLE LISTENER ---
      this.imageOrientationToggle.addEventListener('change', (e) => {
        this.isPortraitMode = e.target.checked;
      });

      // --- ADDED TRANSPARENT BG LISTENER ---
      this.transparentBgToggle.addEventListener('change', (e) => {
        this.isTransparentBackground = e.target.checked;
      });

      // --- ADDED MATERIAL SELECT LISTENER ---
      this.materialSelect.addEventListener('change', (e) => {
        this.materialMode = e.target.value;
        this.huePass.enabled = (this.materialMode === 'Hue'); // Toggle hue effect
        this.updateMeshInstances(); // <-- UPDATED
      });

      // --- ADDED SMOOTH SURFACE LISTENER ---
      this.smoothSurfaceToggle.addEventListener('change', (e) => {
        this.isSmoothSurface = e.target.checked;
        this.updateMeshInstances(); // <-- UPDATED
      });
    }

    /**
     * Starts the canvas recording process.
     */
    startRecording() {
      if (this.isRecording) return;

      // --- ADDED ---
      // Set transparent background for recording if toggled
      if (this.isTransparentBackground) {
        this.originalRecordingAlpha = this.renderer.getClearAlpha();
        this.renderer.setClearAlpha(0);
      }
      // --- END ADDED ---

      this.isRecording = true;
      this.recordedChunks = [];
      this.recordingStatus.classList.remove('hidden');
      this.startRecordingButton.disabled = true;
      this.startRecordingButton.textContent = "Recording...";

      const duration = parseInt(this.recordingDurationInput.value) * 1000; // in ms

      const stream = this.renderer.domElement.captureStream(30); // 30 fps

      // Try common mime types
      const mimeTypes = [
        'video/webm; codecs=vp9',
        'video/webm; codecs=vp8',
        'video/webm'
      ];
      const supportedMimeType = mimeTypes.find(type => MediaRecorder.isTypeSupported(type));

      if (!supportedMimeType) {
        console.error("No supported MIME type for MediaRecorder");

        // --- ADDED RESET LOGIC ---
        this.isRecording = false;
        this.recordingStatus.classList.add('hidden');
        this.startRecordingButton.disabled = false;
        this.startRecordingButton.textContent = "Start Recording";
        // Restore alpha if we changed it
        if (this.originalRecordingAlpha !== undefined) {
          this.renderer.setClearAlpha(this.originalRecordingAlpha);
          this.originalRecordingAlpha = undefined;
        }
        // --- END ADDED ---
        return;
      }

      this.mediaRecorder = new MediaRecorder(stream, { mimeType: supportedMimeType });

      this.mediaRecorder.ondataavailable = (event) => {
        if (event.data.size > 0) {
          this.recordedChunks.push(event.data);
        }
      };

      this.mediaRecorder.onstop = () => {
        this.downloadRecording();
        this.isRecording = false;
        this.recordingStatus.classList.add('hidden');
        this.startRecordingButton.disabled = false;
        this.startRecordingButton.textContent = "Start Recording";

        // --- ADDED ---
        // Restore alpha if we changed it for recording
        if (this.originalRecordingAlpha !== undefined) {
          this.renderer.setClearAlpha(this.originalRecordingAlpha);
          this.originalRecordingAlpha = undefined; // Clear it
        }
        // --- END ADDED ---
      };

      this.mediaRecorder.start();

      // Stop recording after the specified duration
      setTimeout(() => {
        if (this.isRecording && this.mediaRecorder) {
          this.mediaRecorder.stop();
        }
      }, duration);
    }

    /**
     * Downloads the recorded video blob.
     */
    downloadRecording() {
      const blob = new Blob(this.recordedChunks, { type: 'video/webm' });
      const url = URL.createObjectURL(blob);
      this.downloadDataURL(url, 'glitch-visualizer.webm');
    }

    /**
     * Helper function to trigger a download for a Data URL.
     * @param {string} dataURL The data URL (or object URL) to download.
     * @param {string} filename The desired filename.
     */
    downloadDataURL(dataURL, filename) {
      const a = document.createElement('a');
      a.style.display = 'none';
      a.href = dataURL;
      a.download = filename;
      document.body.appendChild(a);
      a.click();
      setTimeout(() => {
        document.body.removeChild(a);
        if (dataURL.startsWith('blob:')) {
          window.URL.revokeObjectURL(dataURL); // Clean up blob URLs
        }
      }, 100);
    }


    /**
     * Saves a high-resolution snapshot of the canvas.
     * This logic is updated to handle transparency.
     */
    saveImage() {
      try {
        const originalAlpha = this.renderer.getClearAlpha();
        if (this.isTransparentBackground) {
          this.renderer.setClearAlpha(0);
        }

        const filename = `glitch-visualizer-${this.isPortraitMode ? 'portrait' : 'landscape'}${this.isTransparentBackground ? '-transparent' : ''}.png`;

        if (!this.isPortraitMode) {
          // --- Standard Landscape Save ---
          if (this.isTransparentBackground) {
            // Force a re-render with the new clear alpha
            this.composer.render();
          }
          const dataURL = this.renderer.domElement.toDataURL('image/png');
          this.downloadDataURL(dataURL, filename);

        } else {
          // --- Portrait Mode Save ---
          const originalWidth = window.innerWidth;
          const originalHeight = window.innerHeight;
          const newHeight = originalHeight;
          const newWidth = Math.floor(newHeight * (9 / 16));

          try {
            // 1. Resize renderer and camera
            this.updateSizes(newWidth, newHeight);

            // 2. Render one frame at new size (will use new alpha if set)
            this.composer.render();

            // 3. Get data URL from the resized canvas
            const dataURL = this.renderer.domElement.toDataURL('image/png');
            this.downloadDataURL(dataURL, filename);

          } catch (e) {
            console.error("Error saving portrait image:", e);
          } finally {
            // 4. ALWAYS restore original size
            this.updateSizes(originalWidth, originalHeight);
          }
        }

        // 5. Restore original clear alpha if we changed it
        if (this.isTransparentBackground) {
          this.renderer.setClearAlpha(originalAlpha);
        }

      } catch (e) {
        console.error("Error saving image:", e);
      }
    }

    /**
     * Handles window resize events to keep the visualizer fullscreen.
     */
    onWindowResize() {
      this.updateSizes(window.innerWidth, window.innerHeight);
    }

    /**
     * Reusable function to update all size-dependent components.
     * @param {number} width The new width (in CSS pixels).
     * @param {number} height The new height (in CSS pixels).
     */
    updateSizes(width, height) {
      const pixelRatio = this.renderer.getPixelRatio();
      const canvasWidth = Math.floor(width * pixelRatio);
      const canvasHeight = Math.floor(height * pixelRatio);

      this.camera.aspect = width / height;
      this.camera.updateProjectionMatrix();

      // Note: setSize handles the pixelRatio internally when not updating style
      this.renderer.setSize(width, height);
      // We still pass the non-multiplied size to setSize,
      // as it uses setPixelRatio internally.

      this.composer.setSize(width, height);

      if (this.smaaPass) {
        // SMAAPass, however, needs the *actual* canvas dimensions
        this.smaaPass.setSize(canvasWidth, canvasHeight);
      }
    }

    /**
     * The main animation loop, called every frame.
     */
    animate() {
      // Must bind 'this' for requestAnimationFrame
      requestAnimationFrame(() => this.animate());

      const now = Date.now(); // Get time once for all calculations

      // --- Update Rotation Speed ---
      if (this.isAutoRotate) {
        // Oscillates between 0.002 and 0.042
        this.rotationSpeed = (Math.sin(now * 0.0005) + 1.1) * 0.02;
      }
      // If auto-rotate is off, this.rotationSpeed is set by the slider's event listener

      // --- UPDATED: Update Visuals ---
      if (this.meshGroup) {
        // Rotate the entire group
        this.meshGroup.rotation.x += this.rotationSpeed / 2.5;
        this.meshGroup.rotation.y += this.rotationSpeed;

        // Add subtle individual rotation
        const individualSpeed = this.rotationSpeed * 0.1;
        this.meshes.forEach(mesh => {
          mesh.rotation.x += individualSpeed;
          mesh.rotation.z += individualSpeed;
        });
      }
      // --- END UPDATED ---

      // --- Update Effects Uniforms ---
      if (this.huePass.enabled) {
        const time = now * 0.0002;
        this.hueValue = Math.sin(time);

        if (this.huePass.uniforms['hue']) {
          this.huePass.uniforms['hue'].value = this.hueValue;
        }
      }

      // --- NEW: Update Film Pass Time ---
      if (this.filmPass && this.filmPass.uniforms && this.filmPass.uniforms.time) {
        this.filmPass.uniforms['time'].value += 0.05; // Animates noise/scanlines
      }

      // --- UPDATED: Control BPM Pulse Effects ---
      if (this.isPulseEffectsEnabled && this.filmPass) {
        const beatInterval = (60 / this.bpm) * 1000;

        // Check if the pulse duration has passed
        if (this.glitchPass.enabled && (now - this.lastBeatTime > this.glitchDuration)) {
          this.glitchPass.enabled = false;
          if (this.rgbShiftPass && this.rgbShiftPass.uniforms && this.rgbShiftPass.uniforms.amount) {
            this.rgbShiftPass.uniforms['amount'].value = 0.0; // Reset RGB shift
          }

          // --- FIX: Check for uniforms object as well ---
          if (this.filmPass && this.filmPass.uniforms && this.filmPass.uniforms.nIntensity && this.filmPass.uniforms.sIntensity) {
            // Reset film grain to base
            this.filmPass.uniforms['nIntensity'].value = this.baseFilmNoise;
            this.filmPass.uniforms['sIntensity'].value = this.baseFilmScanlines;
          }
        }

        // Check if a new beat should trigger
        if (!this.glitchPass.enabled && (now - this.lastBeatTime >= beatInterval)) {
          this.glitchPass.enabled = true; // Enable digital glitch

          if (this.rgbShiftPass && this.rgbShiftPass.uniforms && this.rgbShiftPass.uniforms.amount) {
            this.rgbShiftPass.uniforms['amount'].value = 0.015; // Spike RGB shift
          }

          // --- FIX: Check for uniforms object as well ---
          if (this.filmPass && this.filmPass.uniforms && this.filmPass.uniforms.nIntensity && this.filmPass.uniforms.sIntensity) {
            // Spike film grain (multiply base values)
            this.filmPass.uniforms['nIntensity'].value = this.baseFilmNoise * 5;
            this.filmPass.uniforms['sIntensity'].value = this.baseFilmScanlines * 5;
          }

          this.lastBeatTime = now; // Set new beat time
        }
      }
      // --- END BPM Pulse Effects ---

      // --- NEW: Random Glitch Effects ---
      // Only trigger if no glitch is currently active and the random toggle is on
      if (this.isRandomGlitchEnabled && !this.glitchPass.enabled && Math.random() < 0.015) { // ~1.5% chance per frame
        this.glitchPass.enabled = true;
        if (this.rgbShiftPass?.uniforms?.amount) {
          this.rgbShiftPass.uniforms['amount'].value = 0.005 + Math.random() * 0.02; // Random intensity
        }

        const randomDuration = 50 + Math.random() * 150; // 50ms to 200ms
        setTimeout(() => {
          // We check if the BPM pulse has taken over.
          // If the BPM pulse *just* fired, (now - lastBeatTime) will be small.
          // We only turn off the glitch if the BPM pulse *is not* active.
          const currentTime = Date.now();
          if (currentTime - this.lastBeatTime > this.glitchDuration) {
            this.glitchPass.enabled = false;
            if (this.rgbShiftPass?.uniforms?.amount) {
              this.rgbShiftPass.uniforms['amount'].value = 0.0;
            }
          }
        }, randomDuration);
      }
      // --- END Random Glitch Effects ---

      // --- Auto-Camera Logic ---
      if (this.isAutoCamera) {
        const time = now * 0.0001; // Slower time for camera
        this.camera.position.x = Math.sin(time) * 5;
        this.camera.position.z = Math.cos(time) * 5;
        // --- Adjust camera Y position to look down slightly if multiple objects
        if(this.shapeCount > 1) {
          this.camera.position.y = Math.cos(time * 0.7) * 2; // Slower Y bob
        } else {
          this.camera.position.y = 0;
        }
        this.camera.lookAt(0, 0, 0); // Ensure camera always points to the center
      } else {
        // Reset Y position if auto-camera is off
        if(this.camera.position.y !== 0) {
          this.camera.position.set(0, 0, 5);
          this.camera.lookAt(0, 0, 0);
        }
      }

      // Render the scene (which is necessary for the recorder to capture frames)
      this.composer.render();
    }
  }

  // --- App Initialization ---
  document.addEventListener('DOMContentLoaded', () => {
    const app = new GlitchVisualizer();
    app.init();
  });
</script>
</body>
</html>
