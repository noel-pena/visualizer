<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Glitch Visualizer v4.3 - Fixed Perspective</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    html, body {
      margin: 0;
      padding: 0;
      width: 100%;
      height: 100%;
      overflow: hidden;
      background-color: #000000;
      font-family: 'Inter', sans-serif;
      color: white;
    }

    /* Updated Canvas Layout for Spotify Mode */
    #canvas-container {
      width: 100%;
      height: 100%;
      display: flex;
      justify-content: center;
      align-items: center;
      background-color: #111;
      background-image: radial-gradient(#222 1px, transparent 1px);
      background-size: 20px 20px;
      /* CSS Background properties for the user uploaded image */
      background-repeat: no-repeat;
      background-position: center;
      background-size: cover;
      position: relative;
    }

    canvas {
      display: block;
      /* Important: Canvas must be transparent for CSS BG to show through */
      background: transparent;
      box-shadow: 0 0 10px rgba(0,0,0,0.5);
    }

    /* When 9:16 mode is active */
    canvas.portrait-mode {
      width: auto !important;
      height: 95% !important;
      aspect-ratio: 9 / 16;
      border: 2px solid #333;
      box-shadow: 0 0 50px rgba(0,0,0,0.8);
      border-radius: 8px;
    }

    #controls {
      position: absolute;
      top: 0;
      left: 0;
      background-color: rgba(0, 0, 0, 0.7);
      padding: 0.5rem;
      border-radius: 0 0 8px 0;
      z-index: 10;
      width: 300px;
      backdrop-filter: blur(5px);
      max-height: 100vh;
      display: flex;
      flex-direction: column;
    }
    #controls label {
      display: block;
      margin-bottom: 0.25rem;
      font-size: 0.875rem;
      font-weight: 500;
    }
    #controls input[type="range"] {
      width: 100%;
      margin-bottom: 0.75rem;
    }
    #controls input[type="number"] {
      background-color: rgba(255, 255, 255, 0.1);
      border: 1px solid rgba(255, 255, 255, 0.3);
      border-radius: 4px;
      padding: 0.25rem 0.5rem;
      width: 60px;
    }
    #controls select {
      background-color: rgba(255, 255, 255, 0.1);
      border: 1px solid rgba(255, 255, 255, 0.3);
      border-radius: 4px;
      padding: 0.25rem 0.5rem;
      width: 100%;
      margin-bottom: 0.75rem;
    }
    #start-recording-button:disabled {
      background-color: #4b5563;
      cursor: not-allowed;
    }
  </style>
</head>
<body>

<!-- Updated Container for Canvas -->
<div id="canvas-container">
  <canvas id="visualizer-canvas"></canvas>
</div>

<!-- Controls Section -->
<div id="controls" class="text-white max-h-screen flex flex-col">
  <!-- Toggle Button -->
  <button id="toggle-controls" class="flex items-center text-left flex-shrink-0">
    <svg id="arrow-icon" xmlns="http://www.w3.org/2000/svg" class="h-6 w-6 transition-transform duration-300 transform" fill="none" viewBox="0 0 24 24" stroke="currentColor">
      <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7" />
    </svg>
  </button>

  <!-- Collapsible Content -->
  <div id="controls-content" class="transition-all duration-300 ease-in-out max-h-0 opacity-0 overflow-y-auto">
    <h2 class="text-lg font-semibold pt-2">Controls</h2>
    <div class="mt-4 space-y-4">

      <!-- Auto-Rotate Toggle -->
      <label for="auto-rotate-toggle" class="flex items-center justify-between cursor-pointer">
        <span class="mr-3 text-sm">Auto-Rotate</span>
        <div class="relative">
          <input type="checkbox" id="auto-rotate-toggle" class="sr-only peer" checked>
          <div class="w-14 h-8 bg-gray-600 rounded-full peer-checked:bg-purple-600 transition-colors"></div>
          <div class="absolute left-1 top-1 w-6 h-6 bg-white rounded-full transition-transform peer-checked:translate-x-full"></div>
        </div>
      </label>

      <!-- Rotation Speed Slider -->
      <div id="rotation-slider-container">
        <label for="rotation-slider">Rotation Speed</label>
        <input type="range" id="rotation-slider" min="0" max="0.05" step="0.001" value="0.005" class="w-full mb-2 cursor-pointer">
      </div>

      <!-- AUTO-CAMERA TOGGLE -->
      <label for="auto-camera-toggle" class="flex items-center justify-between cursor-pointer">
        <span class="mr-3 text-sm">Auto-Camera</span>
        <div class="relative">
          <input type="checkbox" id="auto-camera-toggle" class="sr-only peer">
          <div class="w-14 h-8 bg-gray-600 rounded-full peer-checked:bg-purple-600 transition-colors"></div>
          <div class="absolute left-1 top-1 w-6 h-6 bg-white rounded-full transition-transform peer-checked:translate-x-full"></div>
        </div>
      </label>

      <!-- *** SHAPE CONTROLS *** -->
      <div class="pt-4 border-t border-gray-600">
        <h3 class="text-md font-semibold mb-2">Shapes</h3>

        <!-- Shape Selector -->
        <div>
          <label for="shape-select">Shape</label>
          <select id="shape-select">
            <option value="Sphere">Sphere</option>
            <option value="Box">Box</option>
            <option value="Torus">Torus</option>
            <option value="Cone">Cone</option>
          </select>
        </div>

        <!-- MATERIAL SELECTOR -->
        <div>
          <label for="material-select">Material</label>
          <select id="material-select">
            <option value="Hue">Hue (Normal)</option>
            <option value="Monochrome">Monochrome</option>
            <option value="Lit">Lit (White)</option>
          </select>
        </div>

        <!-- SMOOTH SURFACE TOGGLE -->
        <label for="smooth-surface-toggle" class="flex items-center cursor-pointer">
          <span class="mr-3 text-sm">Smooth Surface</span>
          <div class="relative">
            <input type="checkbox" id="smooth-surface-toggle" class="sr-only peer">
            <div class="w-14 h-8 bg-gray-600 rounded-full peer-checked:bg-purple-600 transition-colors"></div>
            <div class="absolute left-1 top-1 w-6 h-6 bg-white rounded-full transition-transform peer-checked:translate-x-full"></div>
          </div>
        </label>

        <!-- SHAPE COUNT SLIDER -->
        <div class="mt-2">
          <label for="shape-count-slider">Shape Count</label>
          <div class="flex justify-between items-center mb-2">
            <input type="range" id="shape-count-slider" min="1" max="50" step="1" value="1" class="w-full cursor-pointer mr-3">
            <span id="shape-count-value" class="text-sm text-gray-300 w-6 text-right">1</span>
          </div>
        </div>

        <!-- Shape-Specific Controls Container -->
        <div id="shape-controls-container">
          <!-- Sphere Controls -->
          <div id="sphere-controls">
            <label for="detail-slider">Sphere Detail</label>
            <div class="flex justify-between items-center mb-2">
              <input type="range" id="detail-slider" min="0" max="50" step="1" value="3" class="w-full cursor-pointer mr-3">
              <span id="detail-value" class="text-sm text-gray-300 w-6 text-right">3</span>
            </div>
          </div>
          <!-- Box Controls -->
          <div id="box-controls" class="hidden">
            <label for="box-segments-slider">Box Segments</label>
            <div class="flex justify-between items-center mb-2">
              <input type="range" id="box-segments-slider" min="1" max="50" step="1" value="1" class="w-full cursor-pointer mr-3">
              <span id="box-segments-value" class="text-sm text-gray-300 w-6 text-right">1</span>
            </div>
          </div>
          <!-- Torus Controls -->
          <div id="torus-controls" class="hidden">
            <label for="torus-radial-slider">Torus Radial Segments</label>
            <div class="flex justify-between items-center mb-2">
              <input type="range" id="torus-radial-slider" min="3" max="100" step="1" value="16" class="w-full cursor-pointer mr-3">
              <span id="torus-radial-value" class="text-sm text-gray-300 w-6 text-right">16</span>
            </div>
            <label for="torus-tubular-slider">Torus Tubular Segments</label>
            <div class="flex justify-between items-center mb-2">
              <input type="range" id="torus-tubular-slider" min="3" max="100" step="1" value="100" class="w-full cursor-pointer mr-3">
              <span id="torus-tubular-value" class="text-sm text-gray-300 w-6 text-right">100</span>
            </div>
          </div>
          <!-- Cone Controls -->
          <div id="cone-controls" class="hidden">
            <label for="cone-segments-slider">Cone Radial Segments</label>
            <div class="flex justify-between items-center mb-2">
              <input type="range" id="cone-segments-slider" min="3" max="100" step="1" value="32" class="w-full cursor-pointer mr-3">
              <span id="cone-segments-value" class="text-sm text-gray-300 w-6 text-right">32</span>
            </div>
          </div>
        </div>
      </div>

      <!-- *** TRANSFORM CONTROLS *** -->
      <div class="pt-4 border-t border-gray-600">
        <h3 class="text-md font-semibold mb-2">Transform (No Distortion)</h3>

        <!-- Position X -->
        <div>
          <label for="pos-x-slider" class="flex justify-between">
            <span>Position X (Left/Right)</span>
            <span id="pos-x-val" class="text-xs text-gray-400">0</span>
          </label>
          <input type="range" id="pos-x-slider" min="-5" max="5" step="0.1" value="0" class="w-full cursor-pointer">
        </div>

        <!-- Position Y -->
        <div>
          <label for="pos-y-slider" class="flex justify-between">
            <span>Position Y (Up/Down)</span>
            <span id="pos-y-val" class="text-xs text-gray-400">0</span>
          </label>
          <input type="range" id="pos-y-slider" min="-5" max="5" step="0.1" value="0" class="w-full cursor-pointer">
        </div>

        <!-- Scale -->
        <div>
          <label for="scale-slider" class="flex justify-between">
            <span>Scale (Size)</span>
            <span id="scale-val" class="text-xs text-gray-400">1</span>
          </label>
          <input type="range" id="scale-slider" min="0.1" max="3" step="0.1" value="1" class="w-full cursor-pointer">
        </div>

        <button id="reset-transform-btn" class="text-xs text-purple-300 underline mt-1">Reset Transform</button>
      </div>


      <!-- --- EFFECTS CONTROLS --- -->
      <div class="pt-4 border-t border-gray-600">
        <h3 class="text-md font-semibold mb-2">Effects</h3>
        <!-- BPM Slider -->
        <div>
          <label for="bpm-slider">BPM</label>
          <div class="flex justify-between items-center mb-2">
            <input type="range" id="bpm-slider" min="60" max="180" step="1" value="120" class="w-full cursor-pointer mr-3">
            <span id="bpm-value" class="text-sm text-gray-300 w-6 text-right">120</span>
          </div>
        </div>

        <!-- BPM PULSE Toggle Switch -->
        <label for="pulse-effects-toggle" class="flex items-center justify-between cursor-pointer">
          <span class="mr-3 text-sm">BPM Pulse Effects</span>
          <div class="relative">
            <input type="checkbox" id="pulse-effects-toggle" class="sr-only peer" checked>
            <div class="w-14 h-8 bg-gray-600 rounded-full peer-checked:bg-purple-600 transition-colors"></div>
            <div class="absolute left-1 top-1 w-6 h-6 bg-white rounded-full transition-transform peer-checked:translate-x-full"></div>
          </div>
        </label>

        <!-- RANDOM GLITCH TOGGLE -->
        <label for="random-glitch-toggle" class="flex items-center justify-between cursor-pointer mt-2">
          <span class="mr-3 text-sm">Random Glitch</span>
          <div class="relative">
            <input type="checkbox" id="random-glitch-toggle" class="sr-only peer">
            <div class="w-14 h-8 bg-gray-600 rounded-full peer-checked:bg-red-600 transition-colors"></div>
            <div class="absolute left-1 top-1 w-6 h-6 bg-white rounded-full transition-transform peer-checked:translate-x-full"></div>
          </div>
        </label>

        <!-- Film Grain Sliders -->
        <div class="mt-4">
          <label for="film-noise-slider">Film Noise</label>
          <input type="range" id="film-noise-slider" min="0" max="2" step="0.05" value="0.2" class="w-full mb-2 cursor-pointer">
        </div>
        <div>
          <label for="film-scanline-slider">Film Scanlines</label>
          <input type="range" id="film-scanline-slider" min="0" max="1" step="0.01" value="0.1" class="w-full mb-2 cursor-pointer">
        </div>

        <!-- AFTERIMAGE CONTROLS -->
        <label for="afterimage-toggle" class="flex items-center justify-between cursor-pointer mt-4">
          <span class="mr-3 text-sm">Afterimage (Trails)</span>
          <div class="relative">
            <input type="checkbox" id="afterimage-toggle" class="sr-only peer">
            <div class="w-14 h-8 bg-gray-600 rounded-full peer-checked:bg-blue-600 transition-colors"></div>
            <div class="absolute left-1 top-1 w-6 h-6 bg-white rounded-full transition-transform peer-checked:translate-x-full"></div>
          </div>
        </label>
        <div class="mt-2">
          <label for="afterimage-damp-slider">Afterimage Damp (Fade)</label>
          <input type="range" id="afterimage-damp-slider" min="0.5" max="0.99" step="0.01" value="0.9" class="w-full mb-2 cursor-pointer">
        </div>

        <!-- DOT SCREEN CONTROLS -->
        <label for="dot-screen-toggle" class="flex items-center justify-between cursor-pointer mt-2">
          <span class="mr-3 text-sm">Dot Screen</span>
          <div class="relative">
            <input type="checkbox" id="dot-screen-toggle" class="sr-only peer">
            <div class="w-14 h-8 bg-gray-600 rounded-full peer-checked:bg-blue-600 transition-colors"></div>
            <div class="absolute left-1 top-1 w-6 h-6 bg-white rounded-full transition-transform peer-checked:translate-x-full"></div>
          </div>
        </label>
        <div class="mt-2">
          <label for="dot-screen-scale-slider">Dot Screen Scale</label>
          <input type="range" id="dot-screen-scale-slider" min="0.1" max="5" step="0.1" value="1" class="w-full mb-2 cursor-pointer">
        </div>
      </div>

      <!-- *** SPOTIFY CANVAS TOOLS *** -->
      <div class="pt-4 border-t border-gray-600">
        <h3 class="text-md font-semibold mb-2">Spotify Canvas Tools</h3>

        <!-- Aspect Ratio Toggle -->
        <label for="force-portrait-toggle" class="flex items-center justify-between cursor-pointer">
          <span class="mr-3 text-sm">Force 9:16 Mode</span>
          <div class="relative">
            <input type="checkbox" id="force-portrait-toggle" class="sr-only peer">
            <div class="w-14 h-8 bg-gray-600 rounded-full peer-checked:bg-green-500 transition-colors"></div>
            <div class="absolute left-1 top-1 w-6 h-6 bg-white rounded-full transition-transform peer-checked:translate-x-full"></div>
          </div>
        </label>

        <!-- Background Image Upload -->
        <div class="mt-4">
          <label class="block text-sm mb-2">Background Image</label>
          <input type="file" id="bg-image-upload" accept="image/*" class="text-sm text-gray-400 file:mr-4 file:py-2 file:px-4 file:rounded-full file:border-0 file:text-sm file:font-semibold file:bg-purple-600 file:text-white hover:file:bg-purple-700"/>
          <button id="clear-bg-button" class="mt-2 text-xs text-red-400 underline hidden">Remove Background</button>
        </div>
      </div>


      <!-- Recording Section -->
      <div class="pt-4 border-t border-gray-600">
        <h3 class="text-md font-semibold mb-2">Recording & Saving</h3>
        <div class="flex items-center justify-between mb-2">
          <label for="recording-duration" class="text-sm">Duration (sec):</label>
          <input type="number" id="recording-duration" min="1" max="60" value="10" class="text-white text-sm">
        </div>
        <button id="start-recording-button" class="w-full bg-purple-600 hover:bg-purple-700 text-white font-bold py-2 px-4 rounded transition-colors">
          Start Recording
        </button>

        <!-- IMAGE ORIENTATION TOGGLE -->
        <label for="image-orientation-toggle" class="flex items-center justify-between cursor-pointer mt-4">
          <span class="mr-3 text-sm">Portrait Snapshot (9:16)</span>
          <div class="relative">
            <input type="checkbox" id="image-orientation-toggle" class="sr-only peer">
            <div class="w-14 h-8 bg-gray-600 rounded-full peer-checked:bg-blue-600 transition-colors"></div>
            <div class="absolute left-1 top-1 w-6 h-6 bg-white rounded-full transition-transform peer-checked:translate-x-full"></div>
          </div>
        </label>

        <!-- TRANSPARENT BG TOGGLE -->
        <label for="transparent-bg-toggle" class="flex items-center justify-between cursor-pointer mt-2">
          <span class="mr-3 text-sm">Transparent Background</span>
          <div class="relative">
            <input type="checkbox" id="transparent-bg-toggle" class="sr-only peer">
            <div class="w-14 h-8 bg-gray-600 rounded-full peer-checked:bg-blue-600 transition-colors"></div>
            <div class="absolute left-1 top-1 w-6 h-6 bg-white rounded-full transition-transform peer-checked:translate-x-full"></div>
          </div>
        </label>

        <button id="save-image-button" class="w-full bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded transition-colors mt-2">
          Save Snapshot
        </button>
        <span id="recording-status" class="text-sm text-yellow-300 mt-2 hidden">Recording...</span>
        <p class="text-xs text-gray-400 mt-2">Saves a .webm file. The clean background will be composited into the video automatically.</p>
      </div>

    </div>
  </div>
</div>


<script type="importmap">
  {
    "imports": {
      "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
      "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
    }
  }
</script>

<script type="module">
  import * as THREE from 'three';
  import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
  import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
  import { GlitchPass } from 'three/addons/postprocessing/GlitchPass.js';
  import { ShaderPass } from 'three/addons/postprocessing/ShaderPass.js';
  import { HueSaturationShader } from 'three/addons/shaders/HueSaturationShader.js';
  import { SMAAPass } from 'three/addons/postprocessing/SMAAPass.js';
  import { FilmPass } from 'three/addons/postprocessing/FilmPass.js';
  import { RGBShiftShader } from 'three/addons/shaders/RGBShiftShader.js';
  import { AfterimagePass } from 'three/addons/postprocessing/AfterimagePass.js';
  import { DotScreenPass } from 'three/addons/postprocessing/DotScreenPass.js';

  class GlitchVisualizer {
    /** @type {THREE.Scene} */
    scene;
    /** @type {THREE.PerspectiveCamera} */
    camera;
    /** @type {THREE.WebGLRenderer} */
    renderer;
    /** @type {EffectComposer} */
    composer;
    /** @type {GlitchPass} */
    glitchPass;
    /** @type {ShaderPass} */
    huePass;
    /** @type {SMAAPass} */
    smaaPass;

    /** @type {THREE.Mesh[]} */
    meshes = [];
    /** @type {THREE.Group} */
    meshGroup;
    /** @type {THREE.PointLight} */
    pointLight;
    /** @type {THREE.AmbientLight} */
    ambientLight;

    /** @type {FilmPass} */
    filmPass;
    /** @type {ShaderPass} */
    rgbShiftPass;
    /** @type {AfterimagePass} */
    afterimagePass;
    /** @type {DotScreenPass} */
    dotScreenPass;

    // --- Canvas & BG Tools ---
    /** @type {HTMLElement} */
    canvasContainer;
    /** @type {HTMLInputElement} */
    forcePortraitToggle;
    /** @type {HTMLInputElement} */
    bgImageUpload;
    /** @type {HTMLButtonElement} */
    clearBgButton;
    /** @type {HTMLImageElement | null} */
    uploadedImageElement = null; // Store the raw image for recording compositing

    // --- Rotation Controls ---
    /** @type {HTMLInputElement} */
    autoRotateToggle;
    /** @type {HTMLInputElement} */
    rotationSlider;
    /** @type {HTMLDivElement} */
    rotationSliderContainer;
    /** @type {boolean} */
    isAutoRotate = true;

    // --- Transform Controls ---
    /** @type {HTMLInputElement} */
    posXSlider;
    /** @type {HTMLInputElement} */
    posYSlider;
    /** @type {HTMLInputElement} */
    scaleSlider;
    /** @type {HTMLSpanElement} */
    posXVal;
    /** @type {HTMLSpanElement} */
    posYVal;
    /** @type {HTMLSpanElement} */
    scaleVal;
    /** @type {HTMLButtonElement} */
    resetTransformBtn;

    // Internal Transform State
    /** @type {number} */
    offsetX = 0;
    /** @type {number} */
    offsetY = 0;
    /** @type {number} */
    currentWidth = 100;
    /** @type {number} */
    currentHeight = 100;


    // --- Camera Controls ---
    /** @type {HTMLInputElement} */
    autoCameraToggle;
    /** @type {boolean} */
    isAutoCamera = false;

    // --- Shape Controls ---
    /** @type {HTMLSelectElement} */
    shapeSelect;
    /** @type {string} */
    currentShape = 'Sphere';
    /** @type {HTMLDivElement} */
    sphereControls;
    /** @type {HTMLInputElement} */
    detailSlider;
    /** @type {HTMLSpanElement} */
    detailValueSpan;
    /** @type {HTMLDivElement} */
    boxControls;
    /** @type {HTMLInputElement} */
    boxSegmentsSlider;
    /** @type {HTMLSpanElement} */
    boxSegmentsValue;
    /** @type {HTMLDivElement} */
    torusControls;
    /** @type {HTMLInputElement} */
    torusRadialSlider;
    /** @type {HTMLSpanElement} */
    torusRadialValue;
    /** @type {HTMLInputElement} */
    torusTubularSlider;
    /** @type {HTMLSpanElement} */
    torusTubularValue;
    /** @type {HTMLDivElement} */
    coneControls;
    /** @type {HTMLInputElement} */
    coneSegmentsSlider;
    /** @type {HTMLSpanElement} */
    coneSegmentsValue;

    // --- Shape Count Controls ---
    /** @type {HTMLInputElement} */
    shapeCountSlider;
    /** @type {HTMLSpanElement} */
    shapeCountValue;
    /** @type {number} */
    shapeCount = 1;

    // --- Other Controls ---
    /** @type {HTMLInputElement} */
    bpmSlider;
    /** @type {HTMLSpanElement} */
    bpmValueSpan;
    /** @type {HTMLInputElement} */
    pulseEffectsToggle;
    /** @type {HTMLSelectElement} */
    materialSelect;
    /** @type {HTMLInputElement} */
    smoothSurfaceToggle;

    // --- Effect Controls ---
    /** @type {HTMLInputElement} */
    filmNoiseSlider;
    /** @type {HTMLInputElement} */
    filmScanlineSlider;
    /** @type {HTMLInputElement} */
    randomGlitchToggle;
    /** @type {HTMLInputElement} */
    afterimageToggle;
    /** @type {HTMLInputElement} */
    afterimageSlider;
    /** @type {HTMLInputElement} */
    dotScreenToggle;
    /** @type {HTMLInputElement} */
    dotScreenSlider;


    // --- UI elements ---
    /** @type {HTMLButtonElement} */
    toggleButton;
    /** @type {HTMLDivElement} */
    controlsContent;
    /** @type {HTMLElement} */
    arrowIcon;

    // --- Recording Properties ---
    /** @type {HTMLInputElement} */
    recordingDurationInput;
    /** @type {HTMLButtonElement} */
    startRecordingButton;
    /** @type {HTMLButtonElement} */
    saveImageButton;
    /** @type {HTMLInputElement} */
    imageOrientationToggle;
    /** @type {HTMLInputElement} */
    transparentBgToggle;
    /** @type {HTMLSpanElement} */
    recordingStatus;
    /** @type {MediaRecorder | null} */
    mediaRecorder = null;
    /** @type {Blob[]} */
    recordedChunks = [];
    /** @type {boolean} */
    isRecording = false;
    /** @type {boolean} */
    isPortraitMode = false;
    /** @type {boolean} */
    isTransparentBackground = false;
    /** @type {string} */
    materialMode = 'Hue';
    /** @type {boolean} */
    isSmoothSurface = false;

    // Composite Recording
    /** @type {HTMLCanvasElement} */
    compositeCanvas;
    /** @type {CanvasRenderingContext2D} */
    compositeCtx;

    /** @type {number} */
    rotationSpeed = 0.005;
    /** @type {number} */
    hueValue = 0;

    // --- Shape Detail Properties ---
    /** @type {number} */
    sphereDetail = 3;
    /** @type {number} */
    boxSegments = 1;
    /** @type {number} */
    torusRadialSeg = 16;
    /** @type {number} */
    torusTubularSeg = 100;
    /** @type {number} */
    coneRadialSeg = 32;


    // --- BPM and Glitch Timing Properties ---
    /** @type {number} */
    bpm = 120;
    /** @type {number} */
    lastBeatTime = 0;
    /** @type {number} */
    glitchDuration = 100;
    /** @type {boolean} */
    isPulseEffectsEnabled = true;

    // --- Effect Properties ---
    /** @type {number} */
    baseFilmNoise = 0.2;
    /** @type {number} */
    baseFilmScanlines = 0.1;
    /** @type {boolean} */
    isRandomGlitchEnabled = false;
    /** @type {boolean} */
    isAfterimageEnabled = false;
    /** @type {boolean} */
    isDotScreenEnabled = false;

    /** @type {boolean} */
    isConstructed = false;

    constructor() {
      const canvas = document.getElementById('visualizer-canvas');
      this.canvasContainer = document.getElementById('canvas-container');

      if (!canvas) {
        console.error("Canvas element not found!");
        return;
      }

      // --- Three.js Setup ---
      this.scene = new THREE.Scene();
      this.camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);

      this.renderer = new THREE.WebGLRenderer({
        canvas: canvas,
        antialias: true,
        preserveDrawingBuffer: true,
        alpha: true // Crucial for CSS background to show through
      });

      this.renderer.setPixelRatio(window.devicePixelRatio);
      this.renderer.setSize(window.innerWidth, window.innerHeight);
      this.renderer.setClearColor(0x000000, 0); // Transparent clear color

      // --- Post-processing Setup ---
      this.composer = new EffectComposer(this.renderer);

      // RenderPass must clear with alpha 0
      const renderPass = new RenderPass(this.scene, this.camera);
      renderPass.clearAlpha = 0;
      this.composer.addPass(renderPass);

      // Glitch Pass
      this.glitchPass = new GlitchPass();
      this.glitchPass.enabled = false;
      this.composer.addPass(this.glitchPass);

      // Film Pass
      this.filmNoiseSlider = document.getElementById('film-noise-slider');
      this.filmScanlineSlider = document.getElementById('film-scanline-slider');
      this.baseFilmNoise = this.filmNoiseSlider ? parseFloat(this.filmNoiseSlider.value) : 0.2;
      this.baseFilmScanlines = this.filmScanlineSlider ? parseFloat(this.filmScanlineSlider.value) : 0.1;

      this.filmPass = new FilmPass(
        this.baseFilmNoise,
        this.baseFilmScanlines,
        648,
        false
      );
      this.composer.addPass(this.filmPass);

      // Hue Pass
      this.huePass = new ShaderPass(HueSaturationShader);
      this.composer.addPass(this.huePass);

      // RGB Shift Pass
      this.rgbShiftPass = new ShaderPass(RGBShiftShader);
      this.rgbShiftPass.uniforms['amount'].value = 0.0;
      this.composer.addPass(this.rgbShiftPass);

      // Dot Screen Pass
      this.dotScreenPass = new DotScreenPass();
      this.dotScreenPass.enabled = false;
      this.composer.addPass(this.dotScreenPass);

      // Afterimage Pass
      this.afterimagePass = new AfterimagePass();
      this.afterimagePass.enabled = false;
      this.composer.addPass(this.afterimagePass);


      // SMAA PASS (MUST BE LAST)
      const pixelRatio = this.renderer.getPixelRatio();
      this.smaaPass = new SMAAPass(
        window.innerWidth * pixelRatio,
        window.innerHeight * pixelRatio
      );
      this.composer.addPass(this.smaaPass);

      // --- UI Elements ---
      this.autoRotateToggle = document.getElementById('auto-rotate-toggle');
      this.rotationSliderContainer = document.getElementById('rotation-slider-container');
      this.rotationSlider = document.getElementById('rotation-slider');

      // --- Transform UI ---
      this.posXSlider = document.getElementById('pos-x-slider');
      this.posYSlider = document.getElementById('pos-y-slider');
      this.scaleSlider = document.getElementById('scale-slider');
      this.posXVal = document.getElementById('pos-x-val');
      this.posYVal = document.getElementById('pos-y-val');
      this.scaleVal = document.getElementById('scale-val');
      this.resetTransformBtn = document.getElementById('reset-transform-btn');

      this.autoCameraToggle = document.getElementById('auto-camera-toggle');

      this.shapeSelect = document.getElementById('shape-select');

      this.sphereControls = document.getElementById('sphere-controls');
      this.detailSlider = document.getElementById('detail-slider');
      this.detailValueSpan = document.getElementById('detail-value');

      this.boxControls = document.getElementById('box-controls');
      this.boxSegmentsSlider = document.getElementById('box-segments-slider');
      this.boxSegmentsValue = document.getElementById('box-segments-value');

      this.torusControls = document.getElementById('torus-controls');
      this.torusRadialSlider = document.getElementById('torus-radial-slider');
      this.torusRadialValue = document.getElementById('torus-radial-value');
      this.torusTubularSlider = document.getElementById('torus-tubular-slider');
      this.torusTubularValue = document.getElementById('torus-tubular-value');

      this.coneControls = document.getElementById('cone-controls');
      this.coneSegmentsSlider = document.getElementById('cone-segments-slider');
      this.coneSegmentsValue = document.getElementById('cone-segments-value');

      this.shapeCountSlider = document.getElementById('shape-count-slider');
      this.shapeCountValue = document.getElementById('shape-count-value');

      this.bpmSlider = document.getElementById('bpm-slider');
      this.bpmValueSpan = document.getElementById('bpm-value');
      this.pulseEffectsToggle = document.getElementById('pulse-effects-toggle');
      this.materialSelect = document.getElementById('material-select');
      this.smoothSurfaceToggle = document.getElementById('smooth-surface-toggle');

      // Effect UI elements
      this.randomGlitchToggle = document.getElementById('random-glitch-toggle');
      this.afterimageToggle = document.getElementById('afterimage-toggle');
      this.afterimageSlider = document.getElementById('afterimage-damp-slider');
      this.dotScreenToggle = document.getElementById('dot-screen-toggle');
      this.dotScreenSlider = document.getElementById('dot-screen-scale-slider');

      // --- Spotify/Canvas Tools ---
      this.forcePortraitToggle = document.getElementById('force-portrait-toggle');
      this.bgImageUpload = document.getElementById('bg-image-upload');
      this.clearBgButton = document.getElementById('clear-bg-button');

      this.toggleButton = document.getElementById('toggle-controls');
      this.controlsContent = document.getElementById('controls-content');
      this.arrowIcon = document.getElementById('arrow-icon');

      // Recording UI Elements
      this.recordingDurationInput = document.getElementById('recording-duration');
      this.startRecordingButton = document.getElementById('start-recording-button');
      this.saveImageButton = document.getElementById('save-image-button');
      this.imageOrientationToggle = document.getElementById('image-orientation-toggle');
      this.transparentBgToggle = document.getElementById('transparent-bg-toggle');
      this.recordingStatus = document.getElementById('recording-status');

      this.meshGroup = new THREE.Group();
      this.scene.add(this.meshGroup);

      // Check if UI elements exist
      if (!this.autoRotateToggle || !this.forcePortraitToggle || !this.bgImageUpload) {
        console.error("Critical UI missing");
      }


      // Set initial values
      this.isAutoRotate = this.autoRotateToggle.checked;
      this.rotationSliderContainer.style.display = this.isAutoRotate ? 'none' : 'block';
      this.rotationSpeed = parseFloat(this.rotationSlider.value);
      this.isAutoCamera = this.autoCameraToggle.checked;
      this.currentShape = this.shapeSelect.value;
      this.sphereDetail = parseInt(this.detailSlider.value);
      this.boxSegments = parseInt(this.boxSegmentsSlider.value);
      this.torusRadialSeg = parseInt(this.torusRadialSlider.value);
      this.torusTubularSeg = parseInt(this.torusTubularSlider.value);
      this.coneRadialSeg = parseInt(this.coneSegmentsSlider.value);
      this.shapeCount = parseInt(this.shapeCountSlider.value);
      this.shapeCountValue.textContent = this.shapeCount;
      this.bpm = parseFloat(this.bpmSlider.value);
      this.bpmValueSpan.textContent = this.bpm;
      this.isPulseEffectsEnabled = this.pulseEffectsToggle.checked;
      this.isPortraitMode = this.imageOrientationToggle.checked;
      this.isTransparentBackground = this.transparentBgToggle.checked;
      this.materialMode = this.materialSelect.value;
      this.isSmoothSurface = this.smoothSurfaceToggle.checked;
      this.huePass.enabled = (this.materialMode === 'Hue');
      this.isRandomGlitchEnabled = this.randomGlitchToggle.checked;
      this.isAfterimageEnabled = this.afterimageToggle.checked;
      this.afterimagePass.enabled = this.isAfterimageEnabled;
      this.afterimagePass.uniforms['damp'].value = parseFloat(this.afterimageSlider.value);
      this.isDotScreenEnabled = this.dotScreenToggle.checked;
      this.dotScreenPass.enabled = this.isDotScreenEnabled;
      this.dotScreenPass.uniforms['scale'].value = parseFloat(this.dotScreenSlider.value);

      this.updateShapeControls();
      this.isConstructed = true;
    }

    init() {
      if (!this.isConstructed) return;
      this.initScene();
      this.setupEventListeners();
      this.onWindowResize(); // Set initial size
      this.updateMeshInstances();
      this.animate();
    }

    updateShapeControls() {
      this.sphereControls.classList.add('hidden');
      this.boxControls.classList.add('hidden');
      this.torusControls.classList.add('hidden');
      this.coneControls.classList.add('hidden');

      switch (this.currentShape) {
        case 'Box':
          this.boxControls.classList.remove('hidden');
          break;
        case 'Torus':
          this.torusControls.classList.remove('hidden');
          break;
        case 'Cone':
          this.coneControls.classList.remove('hidden');
          break;
        case 'Sphere':
        default:
          this.sphereControls.classList.remove('hidden');
          break;
      }
    }

    updateMeshInstances() {
      this.meshes.forEach(mesh => {
        mesh.geometry.dispose();
        if (Array.isArray(mesh.material)) {
          mesh.material.forEach(m => m.dispose());
        } else {
          mesh.material.dispose();
        }
      });
      this.meshGroup.clear();
      this.meshes = [];

      const { geometry, material } = this.createBaseGeometryAndMaterial();

      for (let i = 0; i < this.shapeCount; i++) {
        const mesh = new THREE.Mesh(geometry, material);
        if (this.shapeCount === 1) {
          mesh.position.set(0, 0, 0);
          mesh.rotation.set(0, 0, 0);
        } else {
          mesh.position.set(
            (Math.random() - 0.5) * 7,
            (Math.random() - 0.5) * 7,
            (Math.random() - 0.5) * 7
          );
          mesh.rotation.set(
            Math.random() * 2 * Math.PI,
            Math.random() * 2 * Math.PI,
            Math.random() * 2 * Math.PI
          );
        }
        this.meshGroup.add(mesh);
        this.meshes.push(mesh);
      }

      // Re-apply scale when meshes are rebuilt
      const currentScale = parseFloat(this.scaleSlider.value);
      this.meshGroup.scale.set(currentScale, currentScale, currentScale);
    }


    createBaseGeometryAndMaterial() {
      let geometry;
      switch (this.currentShape) {
        case 'Box':
          const seg = this.boxSegments;
          geometry = new THREE.BoxGeometry(1.5, 1.5, 1.5, seg, seg, seg);
          break;
        case 'Torus':
          geometry = new THREE.TorusGeometry(1, 0.4, this.torusRadialSeg, this.torusTubularSeg);
          break;
        case 'Cone':
          geometry = new THREE.ConeGeometry(1, 2, this.coneRadialSeg, 1, false, 0, Math.PI * 2);
          break;
        case 'Sphere':
        default:
          geometry = new THREE.IcosahedronGeometry(1, this.sphereDetail);
          break;
      }

      let material;
      const wireframe = !this.isSmoothSurface;

      switch (this.materialMode) {
        case 'Monochrome':
          material = new THREE.MeshBasicMaterial({
            color: 0xffffff,
            wireframe: wireframe
          });
          break;
        case 'Lit':
          material = new THREE.MeshPhongMaterial({
            color: 0xffffff,
            wireframe: wireframe,
            flatShading: this.isSmoothSurface
          });
          break;
        case 'Hue':
        default:
          material = new THREE.MeshNormalMaterial({
            wireframe: wireframe,
            flatShading: this.isSmoothSurface
          });
          break;
      }
      return { geometry, material };
    }

    initScene() {
      this.ambientLight = new THREE.AmbientLight(0x404040);
      this.scene.add(this.ambientLight);

      this.pointLight = new THREE.PointLight(0xffffff, 1, 100);
      this.pointLight.position.set(5, 5, 5);
      this.scene.add(this.pointLight);

      this.camera.position.z = 5;
    }

    setupEventListeners() {
      window.addEventListener('resize', () => this.onWindowResize());

      // --- SPOTIFY CANVAS TOOLS LISTENERS ---

      // 1. Force 9:16 Portrait Mode
      this.forcePortraitToggle.addEventListener('change', (e) => {
        const canvas = this.renderer.domElement;
        if (e.target.checked) {
          canvas.classList.add('portrait-mode');
        } else {
          canvas.classList.remove('portrait-mode');
        }
        this.onWindowResize();
      });

      // 2. Background Image Upload - UPDATED FOR CSS
      this.bgImageUpload.addEventListener('change', (e) => {
        const file = e.target.files[0];
        if (!file) return;

        const reader = new FileReader();
        reader.onload = (event) => {
          const dataUrl = event.target.result;

          // Apply to CSS Container (Visuals only)
          this.canvasContainer.style.backgroundImage = `url(${dataUrl})`;
          this.clearBgButton.classList.remove('hidden');

          // Store Image Object for Recording/Saving Compositing
          this.uploadedImageElement = new Image();
          this.uploadedImageElement.src = dataUrl;

          // Ensure Scene BG is null so it's transparent in WebGL
          this.scene.background = null;

          // Disable transparent BG toggle if an image is loaded (conflicts conceptually)
          this.transparentBgToggle.checked = false;
          this.isTransparentBackground = false;
        };
        reader.readAsDataURL(file);
      });

      // 3. Clear Background
      this.clearBgButton.addEventListener('click', () => {
        this.canvasContainer.style.backgroundImage = '';
        this.uploadedImageElement = null;
        this.bgImageUpload.value = '';
        this.clearBgButton.classList.add('hidden');
      });
      // --- END SPOTIFY CANVAS TOOLS LISTENERS ---


      this.autoRotateToggle.addEventListener('change', (e) => {
        this.isAutoRotate = e.target.checked;
        this.rotationSliderContainer.style.display = this.isAutoRotate ? 'none' : 'block';
      });
      this.rotationSlider.addEventListener('input', (e) => {
        this.rotationSpeed = parseFloat(e.target.value);
      });

      // --- TRANSFORM LISTENERS (UPDATED for Lens Shift) ---
      this.posXSlider.addEventListener('input', (e) => {
        this.offsetX = parseFloat(e.target.value);
        this.posXVal.textContent = this.offsetX;
        this.updateCameraOffset();
      });
      this.posYSlider.addEventListener('input', (e) => {
        this.offsetY = parseFloat(e.target.value);
        this.posYVal.textContent = this.offsetY;
        this.updateCameraOffset();
      });
      this.scaleSlider.addEventListener('input', (e) => {
        const val = parseFloat(e.target.value);
        this.scaleVal.textContent = val;
        this.meshGroup.scale.set(val, val, val);
      });
      this.resetTransformBtn.addEventListener('click', () => {
        this.posXSlider.value = 0;
        this.posYSlider.value = 0;
        this.scaleSlider.value = 1;
        this.posXVal.textContent = 0;
        this.posYVal.textContent = 0;
        this.scaleVal.textContent = 1;

        this.offsetX = 0;
        this.offsetY = 0;
        this.meshGroup.scale.set(1, 1, 1);
        this.camera.clearViewOffset();
        this.camera.updateProjectionMatrix();
      });

      this.autoCameraToggle.addEventListener('change', (e) => {
        this.isAutoCamera = e.target.checked;
        if (!this.isAutoCamera) {
          this.camera.position.set(0, 0, 5);
          this.camera.lookAt(0, 0, 0);
        }
      });

      this.shapeSelect.addEventListener('change', (e) => {
        this.currentShape = e.target.value;
        this.updateShapeControls();
        this.updateMeshInstances();
      });

      this.shapeCountSlider.addEventListener('input', (e) => {
        this.shapeCount = parseInt(e.target.value);
        this.shapeCountValue.textContent = this.shapeCount;
        this.updateMeshInstances();
      });

      this.detailSlider.addEventListener('input', (e) => {
        this.sphereDetail = parseInt(e.target.value);
        if (this.detailValueSpan) {
          this.detailValueSpan.textContent = this.sphereDetail;
        }
        this.updateMeshInstances();
      });

      this.boxSegmentsSlider.addEventListener('input', (e) => {
        this.boxSegments = parseInt(e.target.value);
        if (this.boxSegmentsValue) {
          this.boxSegmentsValue.textContent = this.boxSegments;
        }
        this.updateMeshInstances();
      });

      this.torusRadialSlider.addEventListener('input', (e) => {
        this.torusRadialSeg = parseInt(e.target.value);
        if (this.torusRadialValue) {
          this.torusRadialValue.textContent = this.torusRadialSeg;
        }
        this.updateMeshInstances();
      });
      this.torusTubularSlider.addEventListener('input', (e) => {
        this.torusTubularSeg = parseInt(e.target.value);
        if (this.torusTubularValue) {
          this.torusTubularValue.textContent = this.torusTubularSeg;
        }
        this.updateMeshInstances();
      });

      this.coneSegmentsSlider.addEventListener('input', (e) => {
        this.coneRadialSeg = parseInt(e.target.value);
        if (this.coneSegmentsValue) {
          this.coneSegmentsValue.textContent = this.coneRadialSeg;
        }
        this.updateMeshInstances();
      });

      this.bpmSlider.addEventListener('input', (e) => {
        this.bpm = parseFloat(e.target.value);
        if (this.bpmValueSpan) {
          this.bpmValueSpan.textContent = this.bpm;
        }
      });

      this.pulseEffectsToggle.addEventListener('change', (e) => {
        this.isPulseEffectsEnabled = e.target.checked;
        if (!this.isPulseEffectsEnabled) {
          this.glitchPass.enabled = false;
          this.rgbShiftPass.uniforms['amount'].value = 0.0;
          if (this.filmPass && this.filmPass.uniforms && this.filmPass.uniforms.nIntensity && this.filmPass.uniforms.sIntensity) {
            this.filmPass.uniforms['nIntensity'].value = this.baseFilmNoise;
            this.filmPass.uniforms['sIntensity'].value = this.baseFilmScanlines;
          }
        }
      });

      this.randomGlitchToggle.addEventListener('change', (e) => {
        this.isRandomGlitchEnabled = e.target.checked;
      });

      this.filmNoiseSlider.addEventListener('input', (e) => {
        this.baseFilmNoise = parseFloat(e.target.value);
        if (!this.isPulseEffectsEnabled || !this.glitchPass.enabled) {
          if (this.filmPass && this.filmPass.uniforms && this.filmPass.uniforms.nIntensity) {
            this.filmPass.uniforms['nIntensity'].value = this.baseFilmNoise;
          }
        }
      });
      this.filmScanlineSlider.addEventListener('input', (e) => {
        this.baseFilmScanlines = parseFloat(e.target.value);
        if (!this.isPulseEffectsEnabled || !this.glitchPass.enabled) {
          if (this.filmPass && this.filmPass.uniforms && this.filmPass.uniforms.sIntensity) {
            this.filmPass.uniforms['sIntensity'].value = this.baseFilmScanlines;
          }
        }
      });

      this.afterimageToggle.addEventListener('change', (e) => {
        this.isAfterimageEnabled = e.target.checked;
        this.afterimagePass.enabled = this.isAfterimageEnabled;
      });
      this.afterimageSlider.addEventListener('input', (e) => {
        if (this.afterimagePass) {
          this.afterimagePass.uniforms['damp'].value = parseFloat(e.target.value);
        }
      });

      this.dotScreenToggle.addEventListener('change', (e) => {
        this.isDotScreenEnabled = e.target.checked;
        this.dotScreenPass.enabled = this.isDotScreenEnabled;
      });
      this.dotScreenSlider.addEventListener('input', (e) => {
        if (this.dotScreenPass) {
          this.dotScreenPass.uniforms['scale'].value = parseFloat(e.target.value);
        }
      });


      this.toggleButton.addEventListener('click', () => {
        if (this.controlsContent && this.arrowIcon) {
          this.controlsContent.classList.toggle('max-h-0');
          this.controlsContent.classList.toggle('opacity-0');
          this.controlsContent.classList.toggle('flex-1');
          this.controlsContent.classList.toggle('opacity-100');
          this.arrowIcon.classList.toggle('rotate-180');
        }
      });

      this.startRecordingButton.addEventListener('click', () => {
        if (!this.isRecording) {
          this.startRecording();
        }
      });

      this.saveImageButton.addEventListener('click', () => {
        this.saveImage();
      });

      this.imageOrientationToggle.addEventListener('change', (e) => {
        this.isPortraitMode = e.target.checked;
      });

      this.transparentBgToggle.addEventListener('change', (e) => {
        this.isTransparentBackground = e.target.checked;
      });

      this.materialSelect.addEventListener('change', (e) => {
        this.materialMode = e.target.value;
        this.huePass.enabled = (this.materialMode === 'Hue');
        this.updateMeshInstances();
      });

      this.smoothSurfaceToggle.addEventListener('change', (e) => {
        this.isSmoothSurface = e.target.checked;
        this.updateMeshInstances();
      });
    }

    startRecording() {
      if (this.isRecording) return;

      this.isRecording = true;
      this.recordedChunks = [];
      this.recordingStatus.classList.remove('hidden');
      this.startRecordingButton.disabled = true;
      this.startRecordingButton.textContent = "Recording...";

      const duration = parseInt(this.recordingDurationInput.value) * 1000;

      // --- Setup Composite Recording (BG Image + WebGL) ---
      // We need a temporary canvas to draw both the BG image and the WebGL canvas
      // so the stream contains both.
      this.compositeCanvas = document.createElement('canvas');
      this.compositeCanvas.width = this.renderer.domElement.width;
      this.compositeCanvas.height = this.renderer.domElement.height;
      this.compositeCtx = this.compositeCanvas.getContext('2d');

      // Capture stream from the composite canvas, NOT the renderer
      const stream = this.compositeCanvas.captureStream(30);

      const mimeTypes = [
        'video/webm; codecs=vp9',
        'video/webm; codecs=vp8',
        'video/webm'
      ];
      const supportedMimeType = mimeTypes.find(type => MediaRecorder.isTypeSupported(type));

      if (!supportedMimeType) {
        console.error("No supported MIME type for MediaRecorder");
        this.isRecording = false;
        return;
      }

      this.mediaRecorder = new MediaRecorder(stream, { mimeType: supportedMimeType });

      this.mediaRecorder.ondataavailable = (event) => {
        if (event.data.size > 0) {
          this.recordedChunks.push(event.data);
        }
      };

      this.mediaRecorder.onstop = () => {
        this.downloadRecording();
        this.isRecording = false;
        this.recordingStatus.classList.add('hidden');
        this.startRecordingButton.disabled = false;
        this.startRecordingButton.textContent = "Start Recording";

        // Clean up composite canvas
        this.compositeCanvas = null;
        this.compositeCtx = null;
      };

      this.mediaRecorder.start();

      setTimeout(() => {
        if (this.isRecording && this.mediaRecorder) {
          this.mediaRecorder.stop();
        }
      }, duration);
    }

    // Helper to draw the composite frame (called in animate)
    renderCompositeFrame() {
      if (!this.compositeCtx || !this.renderer.domElement) return;

      const width = this.compositeCanvas.width;
      const height = this.compositeCanvas.height;

      // 1. Draw Background
      if (this.uploadedImageElement && !this.isTransparentBackground) {
        // Simulate background-size: cover
        const img = this.uploadedImageElement;
        const imgRatio = img.width / img.height;
        const canvasRatio = width / height;
        let drawWidth, drawHeight, offsetX, offsetY;

        if (imgRatio > canvasRatio) {
          drawHeight = height;
          drawWidth = img.width * (height / img.height);
          offsetX = (width - drawWidth) / 2;
          offsetY = 0;
        } else {
          drawWidth = width;
          drawHeight = img.height * (width / img.width);
          offsetX = 0;
          offsetY = (height - drawHeight) / 2;
        }

        this.compositeCtx.fillStyle = '#111'; // Fallback color
        this.compositeCtx.fillRect(0, 0, width, height);
        this.compositeCtx.drawImage(img, offsetX, offsetY, drawWidth, drawHeight);
      } else {
        // Transparent or Black bg
        this.compositeCtx.clearRect(0, 0, width, height);
        if(!this.isTransparentBackground) {
          this.compositeCtx.fillStyle = '#000';
          this.compositeCtx.fillRect(0,0,width,height);
        }
      }

      // 2. Draw WebGL Canvas on top
      this.compositeCtx.drawImage(this.renderer.domElement, 0, 0);
    }

    downloadRecording() {
      const blob = new Blob(this.recordedChunks, { type: 'video/webm' });
      const url = URL.createObjectURL(blob);
      this.downloadDataURL(url, 'glitch-visualizer.webm');
    }

    downloadDataURL(dataURL, filename) {
      const a = document.createElement('a');
      a.style.display = 'none';
      a.href = dataURL;
      a.download = filename;
      document.body.appendChild(a);
      a.click();
      setTimeout(() => {
        document.body.removeChild(a);
        if (dataURL.startsWith('blob:')) {
          window.URL.revokeObjectURL(dataURL);
        }
      }, 100);
    }


    saveImage() {
      try {
        const filename = `glitch-visualizer-${this.isPortraitMode ? 'portrait' : 'landscape'}${this.isTransparentBackground ? '-transparent' : ''}.png`;

        // Create a temporary canvas for composition
        const tempCanvas = document.createElement('canvas');
        tempCanvas.width = this.renderer.domElement.width;
        tempCanvas.height = this.renderer.domElement.height;
        const ctx = tempCanvas.getContext('2d');

        // 1. Draw Background Image (simulating CSS 'cover')
        if (this.uploadedImageElement && !this.isTransparentBackground) {
          const width = tempCanvas.width;
          const height = tempCanvas.height;
          const img = this.uploadedImageElement;

          // Calculate 'cover' fit
          const imgRatio = img.width / img.height;
          const canvasRatio = width / height;
          let drawWidth, drawHeight, offsetX, offsetY;

          if (imgRatio > canvasRatio) {
            drawHeight = height;
            drawWidth = img.width * (height / img.height);
            offsetX = (width - drawWidth) / 2;
            offsetY = 0;
          } else {
            drawWidth = width;
            drawHeight = img.height * (width / img.width);
            offsetX = 0;
            offsetY = (height - drawHeight) / 2;
          }

          ctx.drawImage(img, offsetX, offsetY, drawWidth, drawHeight);
        }

        // 2. Draw WebGL Content
        this.composer.render(); // Ensure fresh render
        ctx.drawImage(this.renderer.domElement, 0, 0);

        const dataURL = tempCanvas.toDataURL('image/png');
        this.downloadDataURL(dataURL, filename);

      } catch (e) {
        console.error("Error saving image:", e);
      }
    }

    onWindowResize() {
      const container = document.getElementById('canvas-container');

      let width, height;

      if (this.forcePortraitToggle.checked) {
        // Calculate 9:16 dimensions based on available height
        const availableHeight = container.clientHeight * 0.95; // 95% of screen
        height = availableHeight;
        width = height * (9 / 16);
      } else {
        // Full screen
        width = window.innerWidth;
        height = window.innerHeight;
      }

      this.updateSizes(width, height);
    }

    updateSizes(width, height) {
      this.currentWidth = width;
      this.currentHeight = height;

      const pixelRatio = this.renderer.getPixelRatio();
      const canvasWidth = Math.floor(width * pixelRatio);
      const canvasHeight = Math.floor(height * pixelRatio);

      this.camera.aspect = width / height;
      this.camera.updateProjectionMatrix();

      // IMPORTANT: Re-apply offset after resize/aspect change
      this.updateCameraOffset();

      this.renderer.setSize(width, height);
      this.composer.setSize(width, height);

      if (this.smaaPass) {
        this.smaaPass.setSize(canvasWidth, canvasHeight);
      }
    }

    updateCameraOffset() {
      // Calculate pixel offsets based on slider values (-5 to 5)
      // Mapping -5..5 to approximately -halfScreen..halfScreen
      // Note: setViewOffset x is "x coordinate of the top-left corner".
      // To move the object RIGHT, we must shift the view window LEFT (negative x).
      // Since slider + is Right, we invert.

      const xPixelOffset = -this.offsetX * (this.currentWidth / 5);
      const yPixelOffset = this.offsetY * (this.currentHeight / 5);

      this.camera.setViewOffset(
        this.currentWidth,
        this.currentHeight,
        xPixelOffset,
        yPixelOffset,
        this.currentWidth,
        this.currentHeight
      );
      this.camera.updateProjectionMatrix();
    }

    animate() {
      requestAnimationFrame(() => this.animate());

      const now = Date.now();

      if (this.isAutoRotate) {
        this.rotationSpeed = (Math.sin(now * 0.0005) + 1.1) * 0.02;
      }

      if (this.meshGroup) {
        this.meshGroup.rotation.x += this.rotationSpeed / 2.5;
        this.meshGroup.rotation.y += this.rotationSpeed;

        const individualSpeed = this.rotationSpeed * 0.1;
        this.meshes.forEach(mesh => {
          mesh.rotation.x += individualSpeed;
          mesh.rotation.z += individualSpeed;
        });
      }

      if (this.huePass.enabled) {
        const time = now * 0.0002;
        this.hueValue = Math.sin(time);

        if (this.huePass.uniforms['hue']) {
          this.huePass.uniforms['hue'].value = this.hueValue;
        }
      }

      if (this.filmPass && this.filmPass.uniforms && this.filmPass.uniforms.time) {
        this.filmPass.uniforms['time'].value += 0.05;
      }

      if (this.isPulseEffectsEnabled && this.filmPass) {
        const beatInterval = (60 / this.bpm) * 1000;

        if (this.glitchPass.enabled && (now - this.lastBeatTime > this.glitchDuration)) {
          this.glitchPass.enabled = false;
          if (this.rgbShiftPass && this.rgbShiftPass.uniforms && this.rgbShiftPass.uniforms.amount) {
            this.rgbShiftPass.uniforms['amount'].value = 0.0;
          }

          if (this.filmPass && this.filmPass.uniforms && this.filmPass.uniforms.nIntensity && this.filmPass.uniforms.sIntensity) {
            this.filmPass.uniforms['nIntensity'].value = this.baseFilmNoise;
            this.filmPass.uniforms['sIntensity'].value = this.baseFilmScanlines;
          }
        }

        if (!this.glitchPass.enabled && (now - this.lastBeatTime >= beatInterval)) {
          this.glitchPass.enabled = true;

          if (this.rgbShiftPass && this.rgbShiftPass.uniforms && this.rgbShiftPass.uniforms.amount) {
            this.rgbShiftPass.uniforms['amount'].value = 0.015;
          }

          if (this.filmPass && this.filmPass.uniforms && this.filmPass.uniforms.nIntensity && this.filmPass.uniforms.sIntensity) {
            this.filmPass.uniforms['nIntensity'].value = this.baseFilmNoise * 5;
            this.filmPass.uniforms['sIntensity'].value = this.baseFilmScanlines * 5;
          }

          this.lastBeatTime = now;
        }
      }

      if (this.isRandomGlitchEnabled && !this.glitchPass.enabled && Math.random() < 0.015) {
        this.glitchPass.enabled = true;
        if (this.rgbShiftPass?.uniforms?.amount) {
          this.rgbShiftPass.uniforms['amount'].value = 0.005 + Math.random() * 0.02;
        }

        const randomDuration = 50 + Math.random() * 150;
        setTimeout(() => {
          const currentTime = Date.now();
          if (currentTime - this.lastBeatTime > this.glitchDuration) {
            this.glitchPass.enabled = false;
            if (this.rgbShiftPass?.uniforms?.amount) {
              this.rgbShiftPass.uniforms['amount'].value = 0.0;
            }
          }
        }, randomDuration);
      }

      if (this.isAutoCamera) {
        const time = now * 0.0001;
        this.camera.position.x = Math.sin(time) * 5;
        this.camera.position.z = Math.cos(time) * 5;
        if(this.shapeCount > 1) {
          this.camera.position.y = Math.cos(time * 0.7) * 2;
        } else {
          this.camera.position.y = 0;
        }
        this.camera.lookAt(0, 0, 0);
      } else {
        if(this.camera.position.y !== 0) {
          this.camera.position.set(0, 0, 5);
          this.camera.lookAt(0, 0, 0);
        }
      }

      this.composer.render();

      // Update Composite Canvas if Recording
      if (this.isRecording) {
        this.renderCompositeFrame();
      }
    }
  }

  document.addEventListener('DOMContentLoaded', () => {
    const app = new GlitchVisualizer();
    app.init();
  });
</script>
</body>
</html>
