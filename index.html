<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Glitch Visualizer</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    html, body {
      margin: 0;
      padding: 0;
      width: 100%;
      height: 100%;
      overflow: hidden;
      background-color: #000000;
      font-family: 'Inter', sans-serif;
      color: white;
    }
    canvas {
      display: block;
      position: fixed;
      top: 0;
      left: 0;
      z-index: 1;
    }
    #controls {
      position: absolute;
      top: 0;
      left: 0;
      background-color: rgba(0, 0, 0, 0.7);
      padding: 0.5rem;
      border-radius: 0 0 8px 0;
      z-index: 10;
      width: 300px;
      backdrop-filter: blur(5px);
    }
    #controls label {
      display: block;
      margin-bottom: 0.25rem;
      font-size: 0.875rem;
      font-weight: 500;
    }
    #controls input[type="range"] {
      width: 100%;
      margin-bottom: 0.75rem;
    }
    #controls input[type="number"] {
      background-color: rgba(255, 255, 255, 0.1);
      border: 1px solid rgba(255, 255, 255, 0.3);
      border-radius: 4px;
      padding: 0.25rem 0.5rem;
      width: 60px;
    }
    /* Style for disabled recording button */
    #start-recording-button:disabled {
      background-color: #4b5563; /* gray-600 */
      cursor: not-allowed;
    }
  </style>
</head>
<body>
<canvas id="visualizer-canvas"></canvas>

<!-- Updated Controls Section -->
<div id="controls" class="text-white">
  <!-- Toggle Button -->
  <button id="toggle-controls" class="flex items-center text-left">
    <!-- Arrow SVG Icon -->
    <svg id="arrow-icon" xmlns="http://www.w3.org/2000/svg" class="h-6 w-6 transition-transform duration-300 transform" fill="none" viewBox="0 0 24 24" stroke="currentColor">
      <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7" />
    </svg>
  </button>

  <!-- Collapsible Content -->
  <div id="controls-content" class="transition-all duration-300 ease-in-out max-h-0 opacity-0 overflow-hidden">
    <h2 class="text-lg font-semibold pt-2">Controls</h2> <!-- Added text here -->
    <div class="mt-4 space-y-4"> <!-- Added spacing for controls -->

      <!-- Rotation Speed Slider -->
      <div>
        <label for="rotation-slider">Rotation Speed</label>
        <input type="range" id="rotation-slider" min="0" max="0.05" step="0.001" value="0.005" class="w-full mb-2 cursor-pointer">
      </div>

      <!-- Detail Slider -->
      <div>
        <label for="detail-slider">Sphere Detail</label>
        <div class="flex justify-between items-center mb-2">
          <input type="range" id="detail-slider" min="0" max="50" step="1" value="3" class="w-full cursor-pointer mr-3">
          <span id="detail-value" class="text-sm text-gray-300 w-6 text-right">3</span>
        </div>
      </div>

      <!-- BPM Slider -->
      <div>
        <label for="bpm-slider">BPM</label>
        <div class="flex justify-between items-center mb-2">
          <input type="range" id="bpm-slider" min="60" max="180" step="1" value="120" class="w-full cursor-pointer mr-3">
          <span id="bpm-value" class="text-sm text-gray-300 w-6 text-right">120</span>
        </div>
      </div>

      <!-- Glitch Toggle Switch -->
      <label for="glitch-toggle" class="flex items-center cursor-pointer">
        <span class="mr-3 text-sm">Glitch Effect</span>
        <div class="relative">
          <input type="checkbox" id="glitch-toggle" class="sr-only peer" checked>
          <div class="w-14 h-8 bg-gray-600 rounded-full peer-checked:bg-purple-600 transition-colors"></div>
          <div class="absolute left-1 top-1 w-6 h-6 bg-white rounded-full transition-transform peer-checked:translate-x-full"></div>
        </div>
      </label>

      <!-- Recording Section -->
      <div class="pt-4 border-t border-gray-600">
        <h3 class="text-md font-semibold mb-2">Recording</h3>
        <div class="flex items-center justify-between mb-2">
          <label for="recording-duration" class="text-sm">Duration (sec):</label>
          <input type="number" id="recording-duration" min="1" max="60" value="10" class="text-white text-sm">
        </div>
        <button id="start-recording-button" class="w-full bg-purple-600 hover:bg-purple-700 text-white font-bold py-2 px-4 rounded transition-colors">
          Start Recording
        </button>
        <span id="recording-status" class="text-sm text-yellow-300 mt-2 hidden">Recording...</span>
        <p class="text-xs text-gray-400 mt-2">Saves a .webm file. Use an online converter if you need .mp4.</p>
      </div>

    </div>
  </div>
</div>
<!-- End of Updated Controls Section -->


<script type="importmap">
  {
    "imports": {
      "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
      "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
    }
  }
</script>

<!--
  Main application logic.
-->
<script type="module">
  import * as THREE from 'three';
  import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
  import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
  import { GlitchPass } from 'three/addons/postprocessing/GlitchPass.js';
  import { ShaderPass } from 'three/addons/postprocessing/ShaderPass.js';
  import { HueSaturationShader } from 'three/addons/shaders/HueSaturationShader.js';

  /**
   * Main class for the Glitch Visualizer application.
   */
  class GlitchVisualizer {
    /** @type {THREE.Scene} */
    scene;
    /** @type {THREE.PerspectiveCamera} */
    camera;
    /** @type {THREE.WebGLRenderer} */
    renderer;
    /** @type {EffectComposer} */
    composer;
    /** @type {GlitchPass} */
    glitchPass;
    /** @type {ShaderPass} */
    huePass;
    /** @type {THREE.Mesh} */
    mesh;

    /** @type {HTMLInputElement} */
    rotationSlider;
    /** @type {HTMLInputElement} */
    bpmSlider;
    /** @type {HTMLSpanElement} */
    bpmValueSpan;
    /** @type {HTMLInputElement} */
    glitchToggle;
    /** @type {HTMLInputElement} */
    detailSlider;
    /** @type {HTMLSpanElement} */
    detailValueSpan;

    // --- New UI elements for collapsible controls ---
    /** @type {HTMLButtonElement} */
    toggleButton;
    /** @type {HTMLDivElement} */
    controlsContent;
    /** @type {HTMLElement} */
    arrowIcon;
    // --- End of new UI elements ---

    // --- New Recording Properties ---
    /** @type {HTMLInputElement} */
    recordingDurationInput;
    /** @type {HTMLButtonElement} */
    startRecordingButton;
    /** @type {HTMLSpanElement} */
    recordingStatus;
    /** @type {MediaRecorder | null} */
    mediaRecorder = null;
    /** @type {Blob[]} */
    recordedChunks = [];
    /** @type {boolean} */
    isRecording = false;
    // --- End Recording Properties ---

    /** @type {number} */
    rotationSpeed = 0.005;
    /** @type {number} */
    hueValue = 0;
    /** @type {number} */
    sphereDetail = 3;

    // --- BPM and Glitch Timing Properties ---
    /** @type {number} */
    bpm = 120;
    /** @type {number} */
    lastBeatTime = 0;
    /** @type {number} */
    glitchDuration = 100;
    /** @type {boolean} */
    isGlitchEffectEnabled = true;
    // --- End BPM Properties ---

    /** @type {boolean} */
    isConstructed = false; // Flag to check if constructor finished

    constructor() {
      const canvas = document.getElementById('visualizer-canvas');
      if (!canvas) {
        console.error("Canvas element not found!");
        return;
      }

      // --- Three.js Setup ---
      this.scene = new THREE.Scene();
      this.camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
      // CRITICAL: Added preserveDrawingBuffer: true for recording
      this.renderer = new THREE.WebGLRenderer({
        canvas: canvas,
        antialias: true,
        preserveDrawingBuffer: true
      });

      // --- Post-processing (Effect) Setup ---
      this.composer = new EffectComposer(this.renderer);
      const renderPass = new RenderPass(this.scene, this.camera);
      this.composer.addPass(renderPass);

      // Glitch Pass
      this.glitchPass = new GlitchPass();
      this.glitchPass.enabled = false; // Start disabled
      this.composer.addPass(this.glitchPass);

      // Hue Pass
      this.huePass = new ShaderPass(HueSaturationShader);
      this.composer.addPass(this.huePass);

      // --- UI Elements ---
      this.rotationSlider = document.getElementById('rotation-slider');
      this.bpmSlider = document.getElementById('bpm-slider');
      this.bpmValueSpan = document.getElementById('bpm-value');
      this.glitchToggle = document.getElementById('glitch-toggle');
      this.detailSlider = document.getElementById('detail-slider');
      this.detailValueSpan = document.getElementById('detail-value');

      this.toggleButton = document.getElementById('toggle-controls');
      this.controlsContent = document.getElementById('controls-content');
      this.arrowIcon = document.getElementById('arrow-icon');

      // --- Get Recording UI Elements ---
      this.recordingDurationInput = document.getElementById('recording-duration');
      this.startRecordingButton = document.getElementById('start-recording-button');
      this.recordingStatus = document.getElementById('recording-status');

      // Check if all UI elements were found
      if (!this.rotationSlider ||
        !this.bpmSlider || !this.bpmValueSpan ||
        !this.glitchToggle ||
        !this.detailSlider || !this.detailValueSpan ||
        !this.toggleButton || !this.controlsContent || !this.arrowIcon ||
        !this.recordingDurationInput || !this.startRecordingButton || !this.recordingStatus) { // --- Added recording UI check ---
        console.error("Initialization Error: One or more UI elements not found!");
        return; // Return early, isConstructed will be false
      }

      // Set initial values from controls
      this.rotationSpeed = parseFloat(this.rotationSlider.value);
      this.bpm = parseFloat(this.bpmSlider.value);
      this.bpmValueSpan.textContent = this.bpm;
      this.isGlitchEffectEnabled = this.glitchToggle.checked;
      this.sphereDetail = parseInt(this.detailSlider.value);
      this.detailValueSpan.textContent = this.sphereDetail;

      this.isConstructed = true; // All good, set flag
    }

    /**
     * Initializes the scene and event listeners.
     */
    init() {
      if (!this.isConstructed) {
        console.error("Initialization failed: Constructor did not complete.");
        return;
      }

      this.initScene();
      this.setupEventListeners();
      this.onWindowResize(); // Set initial size
      this.animate(); // Start animation loop immediately
    }

    /**
     * Creates or recreates the 3D mesh.
     */
    recreateMesh() {
      if (this.mesh) {
        this.scene.remove(this.mesh);
        this.mesh.geometry.dispose();
        this.mesh.material.dispose();
      }

      // Use radius 1, and detail from slider (as per user's last code)
      const geometry = new THREE.IcosahedronGeometry(1, this.sphereDetail);
      const material = new THREE.MeshNormalMaterial({ wireframe: true });
      this.mesh = new THREE.Mesh(geometry, material);
      this.scene.add(this.mesh);
    }

    /**
     * Creates the 3D objects for the scene.
     */
    initScene() {
      this.recreateMesh(); // Call helper method
      this.camera.position.z = 5;
    }

    /**
     * Sets up event listeners for UI interaction and window resizing.
     */
    setupEventListeners() {
      window.addEventListener('resize', () => this.onWindowResize());

      this.rotationSlider.addEventListener('input', (e) => {
        this.rotationSpeed = parseFloat(e.target.value);
      });

      this.bpmSlider.addEventListener('input', (e) => {
        this.bpm = parseFloat(e.target.value);
        if (this.bpmValueSpan) {
          this.bpmValueSpan.textContent = this.bpm;
        }
      });

      this.detailSlider.addEventListener('input', (e) => {
        this.sphereDetail = parseInt(e.target.value);
        if (this.detailValueSpan) {
          this.detailValueSpan.textContent = this.sphereDetail;
        }
        this.recreateMesh();
      });

      this.glitchToggle.addEventListener('change', (e) => {
        this.isGlitchEffectEnabled = e.target.checked;
        if (!this.isGlitchEffectEnabled && this.glitchPass) {
          this.glitchPass.enabled = false;
        }
      });

      this.toggleButton.addEventListener('click', () => {
        if (this.controlsContent && this.arrowIcon) {
          this.controlsContent.classList.toggle('max-h-0');
          this.controlsContent.classList.toggle('opacity-0');
          this.controlsContent.classList.toggle('max-h-screen'); // Allow full height
          this.controlsContent.classList.toggle('opacity-100');
          this.arrowIcon.classList.toggle('rotate-180');
        }
      });

      // --- Add recording button listener ---
      this.startRecordingButton.addEventListener('click', () => {
        if (!this.isRecording) {
          this.startRecording();
        }
      });
    }

    /**
     * Starts the canvas recording process.
     */
    startRecording() {
      if (this.isRecording) return;

      this.isRecording = true;
      this.recordedChunks = [];
      this.recordingStatus.classList.remove('hidden');
      this.startRecordingButton.disabled = true;
      this.startRecordingButton.textContent = "Recording...";

      const duration = parseInt(this.recordingDurationInput.value) * 1000; // in ms

      const stream = this.renderer.domElement.captureStream(30); // 30 fps

      // Try common mime types
      const mimeTypes = [
        'video/webm; codecs=vp9',
        'video/webm; codecs=vp8',
        'video/webm'
      ];
      const supportedMimeType = mimeTypes.find(type => MediaRecorder.isTypeSupported(type));

      if (!supportedMimeType) {
        console.error("No supported MIME type for MediaRecorder");
        this.stopRecording(); // Reset UI
        return;
      }

      this.mediaRecorder = new MediaRecorder(stream, { mimeType: supportedMimeType });

      this.mediaRecorder.ondataavailable = (event) => {
        if (event.data.size > 0) {
          this.recordedChunks.push(event.data);
        }
      };

      this.mediaRecorder.onstop = () => {
        this.downloadRecording();
        this.isRecording = false;
        this.recordingStatus.classList.add('hidden');
        this.startRecordingButton.disabled = false;
        this.startRecordingButton.textContent = "Start Recording";
      };

      this.mediaRecorder.start();

      // Stop recording after the specified duration
      setTimeout(() => {
        if (this.isRecording && this.mediaRecorder) {
          this.mediaRecorder.stop();
        }
      }, duration);
    }

    /**
     * Downloads the recorded video blob.
     */
    downloadRecording() {
      const blob = new Blob(this.recordedChunks, { type: 'video/webm' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.style.display = 'none';
      a.href = url;
      a.download = 'glitch-visualizer.webm';
      document.body.appendChild(a);
      a.click();
      setTimeout(() => {
        document.body.removeChild(a);
        window.URL.revokeObjectURL(url);
      }, 100);
    }

    /**
     * Handles window resize events to keep the visualizer fullscreen.
     */
    onWindowResize() {
      this.camera.aspect = window.innerWidth / window.innerHeight;
      this.camera.updateProjectionMatrix();
      this.renderer.setSize(window.innerWidth, window.innerHeight);
      // Removed the cap of 2 to render at full native resolution for max crispness
      this.renderer.setPixelRatio(window.devicePixelRatio);
      this.composer.setSize(window.innerWidth, window.innerHeight);
    }

    /**
     * The main animation loop, called every frame.
     */
    animate() {
      // Must bind 'this' for requestAnimationFrame
      requestAnimationFrame(() => this.animate());

      // --- Update Visuals ---
      if (this.mesh) { // Add check in case mesh hasn't been created
        this.mesh.rotation.x += this.rotationSpeed / 2.5;
        this.mesh.rotation.y += this.rotationSpeed;
      }

      // --- Update Effects Uniforms ---
      const time = Date.now() * 0.0002;
      this.hueValue = Math.sin(time);

      if (this.huePass && this.huePass.uniforms['hue']) {
        this.huePass.uniforms['hue'].value = this.hueValue;
      }

      // --- Control Glitch Effect (BPM Logic) ---
      if (this.isGlitchEffectEnabled && this.glitchPass) {
        const now = Date.now();
        const beatInterval = (60 / this.bpm) * 1000;

        // Check if the glitch duration has passed
        if (this.glitchPass.enabled && (now - this.lastBeatTime > this.glitchDuration)) {
          this.glitchPass.enabled = false;
        }

        // Check if a new beat should trigger
        if (!this.glitchPass.enabled && (now - this.lastBeatTime >= beatInterval)) {
          this.glitchPass.enabled = true;
          this.lastBeatTime = now; // Set new beat time
        }
      }

      // Render the scene (which is necessary for the recorder to capture frames)
      this.composer.render();
    }
  }

  // --- App Initialization ---
  document.addEventListener('DOMContentLoaded', () => {
    const app = new GlitchVisualizer();
    app.init();
  });
</script>
</body>
</html>
